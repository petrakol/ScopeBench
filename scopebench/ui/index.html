<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ScopeBench UI</title>
    <style>
      :root { color-scheme: light; font-family: Inter, Arial, sans-serif; }
      body { margin: 0; background: #f3f5f8; color: #111827; }
      main { max-width: 1200px; margin: 24px auto; padding: 0 16px 32px; }
      h1, h2, h3 { margin: 0 0 8px; }
      p { margin: 4px 0 12px; }
      .grid { display: grid; gap: 16px; }
      .two-col { grid-template-columns: repeat(2, minmax(0, 1fr)); }
      .three-col { grid-template-columns: repeat(3, minmax(0, 1fr)); }
      .card { background: #fff; border: 1px solid #d1d5db; border-radius: 10px; padding: 14px; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04); }
      textarea, pre, select, input[type="text"], input[type="number"] { width: 100%; box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
      textarea { min-height: 180px; border: 1px solid #cbd5e1; border-radius: 8px; padding: 8px; }
      pre { margin: 0; background: #0f172a; color: #f8fafc; border-radius: 8px; padding: 10px; overflow-x: auto; min-height: 120px; }
      .controls { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
      button { border: 1px solid #2563eb; background: #2563eb; color: #fff; border-radius: 8px; padding: 8px 12px; cursor: pointer; }
      button.secondary { border-color: #64748b; background: #64748b; }
      .badge { display: inline-block; border-radius: 999px; padding: 2px 8px; font-size: 12px; margin-right: 8px; }
      .allow { background: #dcfce7; color: #166534; }
      .ask { background: #fef3c7; color: #92400e; }
      .deny { background: #fee2e2; color: #991b1b; }
      table { width: 100%; border-collapse: collapse; font-size: 14px; }
      input[type="range"] { width: 100%; }
      .muted { color: #64748b; font-size: 12px; }
      .step-editor {
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        padding: 10px;
        margin-bottom: 10px;
      }
      .slider-grid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px 12px;
      }
      .slider-row {
        padding: 6px;
        border: 1px solid #e5e7eb;
        border-radius: 6px;
      }
      .inline-label {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }
      th, td {
        border-bottom: 1px solid #e5e7eb;
        padding: 6px;
        text-align: left;
        vertical-align: top;
      }
      .wizard-grid {
        display: grid;
        grid-template-columns: repeat(4, minmax(0, 1fr));
        gap: 8px;
      }
      .wizard-grid input,
      .wizard-grid select {
        width: 100%;
        box-sizing: border-box;
        padding: 8px;
        border: 1px solid #cbd5e1;
        border-radius: 8px;
      }
      .step-list {
        margin-top: 10px;
        display: grid;
        gap: 8px;
      }
      .wizard-step {
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        padding: 8px;
        display: grid;
        grid-template-columns: 110px minmax(0, 1fr) 180px;
        gap: 8px;
        align-items: center;
      }
      @media (max-width: 900px) {
        .two-col { grid-template-columns: 1fr; }
      }
      .step-editor, .agent-editor { border: 1px solid #e5e7eb; border-radius: 8px; padding: 10px; margin-bottom: 10px; }
      .slider-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 8px 12px; }
      .slider-row { padding: 6px; border: 1px solid #e5e7eb; border-radius: 6px; }
      .inline-label { display: flex; justify-content: space-between; align-items: center; gap: 8px; }
      .field-grid { display: grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 8px; margin-bottom: 8px; }
      .agent-header { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 8px; }
      .agent-header input[type="text"] { flex: 1; }
      th, td { border-bottom: 1px solid #e5e7eb; padding: 6px; text-align: left; vertical-align: top; }
      @media (max-width: 900px) { .two-col, .three-col, .field-grid { grid-template-columns: 1fr; } }
    </style>
  </head>
  <body>
    <main>
      <h1>ScopeBench Interactive Workbench</h1>
      <p>Author contracts and plans, inspect DAGs, view axis scores/rationales, and replay telemetry.</p>

      <div class="card">
        <div class="controls">
          <button id="load-template" class="secondary">Load template</button>
          <select id="template-select"></select>
          <button id="run">Run /evaluate</button>
          <button id="run-session">Run /evaluate_session</button>
          <button id="replay" class="secondary">Replay telemetry</button>
          <button id="calibration" class="secondary">Calibration dashboard</button>
          <button id="dataset-validate" class="secondary">Validate case draft</button>
          <button id="dataset-suggest" class="secondary">Suggest vectors</button>
          <button id="stream" class="secondary">Stream /evaluate_stream</button>
          <button id="refresh-plugins" class="secondary">Refresh plugins</button>
          <label><input id="auto-run" type="checkbox" checked /> auto-run what-if</label>
        </div>
      </div>

      <section class="card" style="margin-top: 16px">
        <h3>Plan Generation Wizard</h3>
        <p class="muted">Pick a domain preset and variant, then generate/edit a baseline plan from templates.</p>
        <div class="wizard-grid">
          <input id="wizard-goal" placeholder="Goal (e.g., Stabilize flaky checkout tests)" />
          <select id="wizard-domain"></select>
          <select id="wizard-variant"></select>
          <select id="wizard-preset">
            <option value="">(template default)</option>
            <option value="team">team</option>
            <option value="enterprise">enterprise</option>
            <option value="regulated">regulated</option>
          </select>
        </div>
        <div class="controls" style="margin-top: 10px">
          <button id="wizard-generate" class="secondary">Generate baseline</button>
          <button id="wizard-apply">Apply to editor</button>
        </div>
        <div id="wizard-steps" class="step-list"></div>
      </section>

      <section class="grid two-col" style="margin-top: 16px">
        <div class="card">
          <h3>Contract (JSON)</h3>
          <textarea id="contract"></textarea>
        </div>
        <div class="card">
          <h3>Plan (JSON)</h3>
          <textarea id="plan"></textarea>
        </div>
      </section>

      <section class="grid two-col" style="margin-top: 16px">
        <div class="card">
          <h3>Plan DAG</h3>
          <pre id="dag"></pre>
        </div>
        <div class="card">
          <h3>Decision & Trace</h3>
          <div id="decision"></div>
          <pre id="result"></pre>
        </div>
      </section>

      <section class="grid two-col" style="margin-top: 16px">
        <div class="card">
          <h3>Axis Scores</h3>
          <table><thead><tr><th>Axis</th><th>Score</th></tr></thead><tbody id="axis-table"></tbody></table>
        </div>
        <div class="card">
          <h3>Per-axis Rationales (LLM Judge + rules)</h3>
          <table><thead><tr><th>Step</th><th>Axis</th><th>Score</th><th>Confidence</th><th>Rationale</th></tr></thead><tbody id="rationale-table"></tbody></table>
        </div>
      </section>

      <section class="card" style="margin-top: 16px">
        <h3>Explainability: Aggregate Risk Contributions</h3>
        <p class="muted">Shows each step's contribution along the dominant risk path per axis.</p>
        <table><thead><tr><th>Axis</th><th>Aggregate</th><th>Critical path terminal</th><th>Step contributions</th></tr></thead><tbody id="contrib-table"></tbody></table>
      </section>

      <section class="card" style="margin-top: 16px">
        <h3>Streaming Evaluation Timeline</h3>
        <p class="muted">Simulate evolving plans and visualize risk growth, threshold crossings, and rationale deltas from judge outputs.</p>
        <pre id="streaming"></pre>
      </section>

      <section class="card" style="margin-top: 16px">
        <h3>What-if Lab</h3>
        <p class="muted">Adjust descriptions, tools, and effect magnitudes. Updates flow into plan JSON and re-evaluate automatically.</p>
        <div id="whatif-editors"></div>
      </section>

      <section class="card" style="margin-top: 16px">
        <h3>Multi-agent Session Builder</h3>
        <p class="muted">Compose per-agent plans, tune team/global budgets, and inspect laundering signals and aggregate budget pressure.</p>
        <div class="field-grid">
          <label>Global budget: cost_usd<input id="session-budget-cost" type="number" min="0" step="1" value="150" /></label>
          <label>Global budget: time_horizon_days<input id="session-budget-time" type="number" min="0" step="1" value="7" /></label>
          <label>Global budget: max_tool_calls<input id="session-budget-tools" type="number" min="0" step="1" value="6" /></label>
        </div>
        <div class="controls" style="margin-bottom:10px">
          <button id="add-agent" class="secondary">Add agent</button>
          <button id="sync-from-current-plan" class="secondary">Sync current plan as agent-1</button>
        </div>
        <div id="agent-editors"></div>
      </section>

      <section class="grid two-col" style="margin-top: 16px">
        <div class="card">
          <h3>Session payload preview</h3>
          <pre id="session-payload"></pre>
        </div>
        <div class="card">
          <h3>Session result</h3>
          <div id="session-decision"></div>
          <pre id="session-result"></pre>
        </div>
      </section>
      <section class="grid two-col" style="margin-top: 16px">
        <div class="card">
          <h3>Plugin Marketplace</h3>
          <p class="muted">Community plugin listings from <code>docs/plugin_marketplace.yaml</code>.</p>
          <pre id="plugin-marketplace"></pre>
        </div>
        <div class="card">
          <h3>Plugin Manager</h3>
          <div class="controls" style="margin-bottom: 8px;">
            <input id="plugin-source" placeholder="/path/to/plugin-bundle.yaml" style="flex:1; min-width: 220px;" />
            <input id="plugin-target-dir" placeholder="/path/to/plugins-dir" style="flex:1; min-width: 220px;" />
          </div>
          <div class="controls" style="margin-bottom: 8px;">
            <button id="plugin-install">Install bundle</button>
            <button id="plugin-uninstall" class="secondary">Uninstall bundle</button>
          </div>
          <pre id="plugin-manager"></pre>
        </div>
      </section>

      <section class="grid" style="margin-top: 16px">
        <div class="card">
          <h3>Global aggregate & laundering detection</h3>
          <table><thead><tr><th>Metric</th><th>Value</th></tr></thead><tbody id="session-global-table"></tbody></table>
          <h4 style="margin-top:12px">Laundering signals</h4>
          <table><thead><tr><th>Axis</th><th>Global</th><th>Max agent</th><th>Delta</th><th>Ask threshold</th></tr></thead><tbody id="session-laundering-table"></tbody></table>
        </div>
      </section>

      <section class="card" style="margin-top: 16px">
        <h3>Dataset Contribution Draft</h3>
        <p class="muted">Validate a case object and auto-suggest calibrated step vectors from the current contract+plan.</p>
        <textarea id="case-draft" style="min-height: 220px"></textarea>
        <pre id="dataset-output"></pre>
      </section>

      <section class="grid two-col" style="margin-top: 16px">
        <div class="card"><h3>Catalog</h3><pre id="catalog"></pre></div>
        <div class="card"><h3>Telemetry Replay</h3><pre id="telemetry"></pre></div>
      </section>
      <section class="grid" style="margin-top: 16px">
        <div class="card">
          <h3>Calibration Dashboard</h3>
          <p class="muted">Interactive analytics for telemetry-driven calibration, thresholds, and simulated plan impact.</p>
          <div class="controls" style="margin-bottom:8px">
            <label>Domain <select id="calibration-domain"></select></label>
            <label>Sample plan preset
              <select id="calibration-plan-preset">
                <option value="team">team</option>
                <option value="enterprise">enterprise</option>
                <option value="regulated">regulated</option>
                <option value="personal">personal</option>
              </select>
            </label>
          </div>
          <div class="grid two-col" id="calibration-controls"></div>
          <div class="grid two-col" style="margin-top:10px">
            <div><h4>Per-axis score distributions</h4><pre id="calibration-distributions"></pre></div>
            <div><h4>False-alarm vs override rates</h4><pre id="calibration-rates"></pre></div>
          </div>
          <div class="grid two-col" style="margin-top:10px">
            <div><h4>Preset thresholds</h4><pre id="calibration-thresholds"></pre></div>
            <div><h4>Sample plan threshold pressure</h4><pre id="calibration-plan-impact"></pre></div>
          </div>
          <h4 style="margin-top:10px">Raw payload</h4>
          <pre id="calibration-dashboard"></pre>
        </div>
      </section>
    </main>

    <script>
      const defaultContract = { goal: "Fix flaky CI test", preset: "team" };
      const defaultPlan = {
        task: "Fix flaky CI test",
        steps: [
          { id: "1", description: "Inspect failing test", tool: "git_read" },
          { id: "2", description: "Patch timing", tool: "git_patch", depends_on: ["1"] },
          { id: "3", description: "Run pytest", tool: "pytest", depends_on: ["2"] }
        ]
      };

      const defaultSessionState = {
        agents: [
          { agent_id: "agent-a", task: "Fix parser bug", plan: { task: "Fix parser bug", steps: [{ id: "1", description: "Read failing unit test and source", tool: "git_read" }, { id: "2", description: "Apply minimal parser patch", tool: "git_patch", depends_on: ["1"] }] } },
          { agent_id: "agent-b", task: "Validate parser patch", plan: { task: "Validate parser patch", steps: [{ id: "1", description: "Review impact and identify tests", tool: "analysis" }, { id: "2", description: "Run targeted tests", tool: "pytest", depends_on: ["1"] }] } }
        ]
      };

      const el = (id) => document.getElementById(id);
      const contractEl = el("contract");
      const planEl = el("plan");
      const dagEl = el("dag");
      const resultEl = el("result");
      const decisionEl = el("decision");
      const axisTableEl = el("axis-table");
      const rationaleTableEl = el("rationale-table");
      const contribTableEl = el("contrib-table");
      const whatIfEditorsEl = el("whatif-editors");
      const catalogEl = el("catalog");
      const telemetryEl = el("telemetry");
      const calibrationDashboardEl = el("calibration-dashboard");
      const calibrationDomainEl = el("calibration-domain");
      const calibrationControlsEl = el("calibration-controls");
      const calibrationDistributionsEl = el("calibration-distributions");
      const calibrationRatesEl = el("calibration-rates");
      const calibrationThresholdsEl = el("calibration-thresholds");
      const calibrationPlanImpactEl = el("calibration-plan-impact");
      const calibrationPlanPresetEl = el("calibration-plan-preset");
      const streamingEl = el("streaming");
      const pluginMarketplaceEl = el("plugin-marketplace");
      const pluginManagerEl = el("plugin-manager");
      const pluginSourceEl = el("plugin-source");
      const pluginTargetDirEl = el("plugin-target-dir");
      const templateSelectEl = el("template-select");
      const autoRunEl = el("auto-run");
      const wizardGoalEl = el("wizard-goal");
      const wizardDomainEl = el("wizard-domain");
      const wizardVariantEl = el("wizard-variant");
      const wizardPresetEl = el("wizard-preset");
      const wizardStepsEl = el("wizard-steps");
      const caseDraftEl = el("case-draft");
      const datasetOutputEl = el("dataset-output");
      const EFFECT_AXES = [
        ["resources", "resource_intensity"],
        ["legal", "legal_exposure"],
        ["stakeholders", "stakeholder_radius"],
        ["irreversible_actions", "irreversibility"],
        ["geo_scope", "spatial"],
        ["time_horizon", "temporal"]
      ];
      const agentEditorsEl = el("agent-editors");
      const sessionPayloadEl = el("session-payload");
      const sessionDecisionEl = el("session-decision");
      const sessionResultEl = el("session-result");
      const sessionAgentTableEl = el("session-agent-table");
      const sessionGlobalTableEl = el("session-global-table");
      const sessionLaunderingTableEl = el("session-laundering-table");
      const MAGNITUDE = ["none", "low", "medium", "high", "extreme"];
      let knownTools = [];
      let autoTimer = null;
      let wizardTemplates = [];
      let wizardDraft = null;
      let sessionState = JSON.parse(JSON.stringify(defaultSessionState));
      let calibrationDashboardState = null;
      let calibrationSelection = { domain: null, axisScaleDelta: {}, axisThresholdFactorDelta: {}, abstainDelta: 0.0 };

      contractEl.value = JSON.stringify(defaultContract, null, 2);
      planEl.value = JSON.stringify(defaultPlan, null, 2);
      caseDraftEl.value = JSON.stringify({
        case_schema_version: "1.0",
        id: "community_case_001",
        domain: "engineering",
        instruction: "Fix flaky CI test",
        contract: defaultContract,
        plan: defaultPlan,
        expected_decision: "ALLOW",
        expected_rationale: "Scoped to local test stabilization with validation.",
        expected_step_vectors: [
          {
            step_id: "1", spatial: 0.1, temporal: 0.1, depth: 0.1, irreversibility: 0.1,
            resource_intensity: 0.1, legal_exposure: 0.1, dependency_creation: 0.1,
            stakeholder_radius: 0.1, power_concentration: 0.1, uncertainty: 0.2
          },
          {
            step_id: "2", spatial: 0.2, temporal: 0.2, depth: 0.3, irreversibility: 0.2,
            resource_intensity: 0.2, legal_exposure: 0.1, dependency_creation: 0.2,
            stakeholder_radius: 0.2, power_concentration: 0.2, uncertainty: 0.3
          },
          {
            step_id: "3", spatial: 0.1, temporal: 0.1, depth: 0.2, irreversibility: 0.1,
            resource_intensity: 0.1, legal_exposure: 0.1, dependency_creation: 0.1,
            stakeholder_radius: 0.1, power_concentration: 0.1, uncertainty: 0.2
          }
        ]
      }, null, 2);

      function decisionBadge(decision) { const n = String(decision || "").toLowerCase(); const cls = n === "allow" ? "allow" : n === "ask" ? "ask" : "deny"; return `<span class="badge ${cls}">${decision || "UNKNOWN"}</span>`; }
      function toMagnitude(v) { return MAGNITUDE[Math.max(0, Math.min(MAGNITUDE.length - 1, Math.round(Number(v || 0) * 4)))]; }
      function renderDag(plan) {
        const nodes = (plan.steps || []).map((s) => `${s.id} [${s.tool || "none"}]`).join("\n");
        const edges = (plan.steps || []).flatMap((s) => (s.depends_on || []).map((dep) => `${dep} -> ${s.id}`)).join("\n");
        dagEl.textContent = `nodes:\n${nodes || "(none)"}\n\nedges:\n${edges || "(none)"}`;
      }

      function renderAggregate(aggregate = {}) { axisTableEl.innerHTML = ""; Object.entries(aggregate).sort((a, b) => b[1] - a[1]).forEach(([axis, score]) => { const tr = document.createElement("tr"); tr.innerHTML = `<td>${axis}</td><td>${Number(score).toFixed(3)}</td>`; axisTableEl.appendChild(tr); }); }
      function renderStepRationales(steps = []) {
        rationaleTableEl.innerHTML = "";
        const rows = [];
        steps.forEach((step) => Object.entries(step.axes || {}).forEach(([axis, detail]) => rows.push({ step: step.step_id || "unknown", axis, ...detail })));
        rows.sort((a, b) => b.value - a.value).forEach((row) => { const tr = document.createElement("tr"); tr.innerHTML = `<td>${row.step}</td><td>${row.axis}</td><td>${Number(row.value).toFixed(3)}</td><td>${Number(row.confidence || 0).toFixed(2)}</td><td>${row.rationale || "n/a"}</td>`; rationaleTableEl.appendChild(tr); });
      }

      function topoOrder(plan) {
        const remaining = {}; (plan.steps || []).forEach((s) => { remaining[s.id] = [...(s.depends_on || [])]; });
        const ready = (plan.steps || []).filter((s) => !(s.depends_on || []).length).map((s) => s.id); const order = [];
        while (ready.length) { const node = ready.pop(); order.push(node); Object.entries(remaining).forEach(([stepId, deps]) => { const idx = deps.indexOf(node); if (idx >= 0) { deps.splice(idx, 1); if (!deps.length && !order.includes(stepId) && !ready.includes(stepId)) ready.push(stepId); } }); }
        return order;
      }

      function computeContributions(plan, steps, aggregate = {}) {
        const axes = Object.keys(aggregate || {}); const vectors = {};
        (steps || []).forEach((step) => { vectors[step.step_id] = Object.fromEntries(Object.entries(step.axes || {}).map(([axis, detail]) => [axis, Number(detail.value || 0)])); });
        const predecessors = Object.fromEntries((plan.steps || []).map((s) => [s.id, s.depends_on || []]));
        const order = topoOrder(plan); const pathScope = {}; const parentByAxis = {}; const deltaByAxis = {};
        order.forEach((stepId) => { pathScope[stepId] = {}; parentByAxis[stepId] = {}; deltaByAxis[stepId] = {}; axes.forEach((axis) => { let baseline = 0; let winnerPred = null; (predecessors[stepId] || []).forEach((pred) => { const predValue = pathScope[pred]?.[axis] ?? 0; if (predValue >= baseline) { baseline = predValue; winnerPred = pred; } }); const stepAxis = vectors[stepId]?.[axis] ?? 0; const updated = Math.max(baseline, stepAxis); pathScope[stepId][axis] = updated; parentByAxis[stepId][axis] = winnerPred; deltaByAxis[stepId][axis] = Math.max(0, updated - baseline); }); });
        return axes.map((axis) => { const agg = Number(aggregate[axis] || 0); let terminal = null; order.forEach((stepId) => { if ((pathScope[stepId]?.[axis] ?? 0) >= (pathScope[terminal]?.[axis] ?? -1)) terminal = stepId; }); const contributions = []; let cursor = terminal; while (cursor) { const delta = Number(deltaByAxis[cursor]?.[axis] || 0); if (delta > 0 || cursor === terminal) contributions.push({ stepId: cursor, delta }); cursor = parentByAxis[cursor]?.[axis] || null; } contributions.reverse(); const text = contributions.map((c) => `${c.stepId}: ${(agg > 0 ? (100 * c.delta) / agg : 0).toFixed(1)}% (${c.delta.toFixed(3)})`).join(" → "); return { axis, aggregate: agg, terminal, text: text || "(none)" }; });
      }
      function renderContributions(plan, steps, aggregate) { contribTableEl.innerHTML = ""; computeContributions(plan, steps, aggregate).sort((a, b) => b.aggregate - a.aggregate).forEach((entry) => { const tr = document.createElement("tr"); tr.innerHTML = `<td>${entry.axis}</td><td>${entry.aggregate.toFixed(3)}</td><td>${entry.terminal || "n/a"}</td><td>${entry.text}</td>`; contribTableEl.appendChild(tr); }); }

      function updatePlanField(stepIndex, field, value) { const plan = JSON.parse(planEl.value); if (!plan.steps?.[stepIndex]) return; plan.steps[stepIndex][field] = value; planEl.value = JSON.stringify(plan, null, 2); scheduleAutoEvaluate(); }
      function updateEffectMagnitude(stepIndex, effectKey, sliderValue) {
        const plan = JSON.parse(planEl.value); const step = plan.steps?.[stepIndex]; if (!step) return;
        step.effects = step.effects || {}; step.effects[effectKey] = toMagnitude(sliderValue); planEl.value = JSON.stringify(plan, null, 2); scheduleAutoEvaluate();
      }

      function renderWhatIfEditors(plan) {
        whatIfEditorsEl.innerHTML = "";
        (plan.steps || []).forEach((step, stepIndex) => {
          const container = document.createElement("div"); container.className = "step-editor";
          const options = knownTools.map((tool) => `<option value="${tool}" ${step.tool === tool ? "selected" : ""}>${tool}</option>`).join("");
          const sliders = EFFECT_AXES.map(([effectKey, axisKey]) => { const raw = step.effects?.[effectKey] || "none"; const value = Math.max(0, MAGNITUDE.indexOf(raw)) / (MAGNITUDE.length - 1); return `<div class="slider-row"><div class="inline-label"><strong>${axisKey}</strong><span>${raw}</span></div><input type="range" min="0" max="1" step="0.25" value="${value}" data-step="${stepIndex}" data-effect="${effectKey}" /></div>`; }).join("");
          container.innerHTML = `<h4>${step.id}</h4><label>Description</label><textarea data-field="description" data-step="${stepIndex}" style="min-height:72px">${step.description || ""}</textarea><label>Tool</label><select data-field="tool" data-step="${stepIndex}">${options}</select><div class="slider-grid" style="margin-top:10px">${sliders}</div>`;
          whatIfEditorsEl.appendChild(container);
        });
        whatIfEditorsEl.querySelectorAll("textarea[data-field], select[data-field]").forEach((node) => node.addEventListener("input", (ev) => updatePlanField(Number(ev.target.dataset.step), ev.target.dataset.field, ev.target.value)));
        whatIfEditorsEl.querySelectorAll("input[type='range']").forEach((node) => node.addEventListener("input", (ev) => { const value = Number(ev.target.value); ev.target.previousElementSibling.querySelector("span").textContent = toMagnitude(value); updateEffectMagnitude(Number(ev.target.dataset.step), ev.target.dataset.effect, value); }));
      }

      function sessionPayloadFromState() {
        const baseContract = JSON.parse(contractEl.value);
        const budgets = {
          cost_usd: Number(el("session-budget-cost").value || 0),
          time_horizon_days: Number(el("session-budget-time").value || 0),
          max_tool_calls: Number(el("session-budget-tools").value || 0)
        };
        const global_contract = { ...baseContract, preset: baseContract.preset || "team", budgets };
        return {
          session: {
            global_contract,
            agents: sessionState.agents.map((agent) => ({ agent_id: agent.agent_id })),
            plans: sessionState.agents.map((agent) => ({ agent_id: agent.agent_id, plan: agent.plan }))
          },
          include_steps: false,
          include_telemetry: true
        };
      }

      function renderSessionBuilder() {
        agentEditorsEl.innerHTML = "";
        sessionState.agents.forEach((agent, idx) => {
          const node = document.createElement("div");
          node.className = "agent-editor";
          node.innerHTML = `<div class="agent-header"><input type="text" value="${agent.agent_id}" data-agent-id="${idx}" /><button class="secondary" data-remove-agent="${idx}">remove</button></div><label>Agent plan (JSON)</label><textarea data-agent-plan="${idx}" style="min-height:130px">${JSON.stringify(agent.plan, null, 2)}</textarea>`;
          agentEditorsEl.appendChild(node);
        });
        sessionPayloadEl.textContent = JSON.stringify(sessionPayloadFromState(), null, 2);

        agentEditorsEl.querySelectorAll("input[data-agent-id]").forEach((node) => node.addEventListener("input", (ev) => {
          sessionState.agents[Number(ev.target.dataset.agentId)].agent_id = ev.target.value.trim() || `agent-${Number(ev.target.dataset.agentId) + 1}`;
          sessionPayloadEl.textContent = JSON.stringify(sessionPayloadFromState(), null, 2);
        }));
        agentEditorsEl.querySelectorAll("textarea[data-agent-plan]").forEach((node) => node.addEventListener("input", (ev) => {
          const idx = Number(ev.target.dataset.agentPlan);
          try { sessionState.agents[idx].plan = JSON.parse(ev.target.value); }
          catch (_err) { sessionPayloadEl.textContent = "Session payload invalid: fix plan JSON to continue."; return; }
          sessionPayloadEl.textContent = JSON.stringify(sessionPayloadFromState(), null, 2);
        }));
        agentEditorsEl.querySelectorAll("button[data-remove-agent]").forEach((node) => node.addEventListener("click", (ev) => {
          const idx = Number(ev.target.dataset.removeAgent);
          sessionState.agents.splice(idx, 1);
          renderSessionBuilder();
        }));
      }

      function topAxesText(aggregate = {}) { return Object.entries(aggregate).sort((a, b) => b[1] - a[1]).slice(0, 3).map(([axis, value]) => `${axis}:${Number(value).toFixed(2)}`).join(", "); }
      function budgetUtilizationText(util = {}) { return Object.entries(util).map(([k, v]) => `${k}:${(100 * Number(v || 0)).toFixed(0)}%`).join(", ") || "n/a"; }

      function renderSessionDashboard(payload = {}) {
        sessionAgentTableEl.innerHTML = ""; sessionGlobalTableEl.innerHTML = ""; sessionLaunderingTableEl.innerHTML = "";
        Object.entries(payload.dashboard?.per_agent || {}).forEach(([agentId, entry]) => {
          const tr = document.createElement("tr");
          tr.innerHTML = `<td>${agentId}</td><td>${decisionBadge(entry.decision)}</td><td>${topAxesText(entry.aggregate)}</td><td>${budgetUtilizationText(entry.budget_utilization)}</td>`;
          sessionAgentTableEl.appendChild(tr);
        });
        const global = payload.dashboard?.global || {};
        [["Decision", global.decision || payload.decision || "n/a"], ["Top axes", topAxesText(global.aggregate || {})], ["Budget utilization", budgetUtilizationText(global.budget_utilization || {})], ["Negotiation triggered", payload.negotiation?.triggered ? "yes" : "no"]].forEach(([k, v]) => {
          const tr = document.createElement("tr"); tr.innerHTML = `<td>${k}</td><td>${v}</td>`; sessionGlobalTableEl.appendChild(tr);
        });
        (payload.laundering_signals || []).forEach((signal) => {
          const tr = document.createElement("tr");
          tr.innerHTML = `<td>${signal.axis}</td><td>${Number(signal.global_value).toFixed(3)}</td><td>${Number(signal.max_agent_value).toFixed(3)}</td><td>${Number(signal.delta).toFixed(3)}</td><td>${Number(signal.ask_threshold).toFixed(3)}</td>`;
          sessionLaunderingTableEl.appendChild(tr);
        });
        if (!(payload.laundering_signals || []).length) {
          const tr = document.createElement("tr"); tr.innerHTML = "<td colspan='5'>No cross-agent laundering signals detected.</td>"; sessionLaunderingTableEl.appendChild(tr);
        }
      }


      function renderWizardVariantOptions() {
        const picked = wizardTemplates.find((item) => item.domain === wizardDomainEl.value);
        const variants = Object.keys(picked?.variants || {}).sort();
        wizardVariantEl.innerHTML = variants.map((v) => `<option value="${v}">${v}</option>`).join("");
      }

      function renderWizardSteps(plan) {
        wizardStepsEl.innerHTML = "";
        (plan.steps || []).forEach((step, idx) => {
          const row = document.createElement("div");
          row.className = "wizard-step";
          row.innerHTML = `
            <strong>${step.id || `step-${idx + 1}`}</strong>
            <input data-step="${idx}" data-field="description" value="${(step.description || "").replace(/"/g, "&quot;")}" />
            <input data-step="${idx}" data-field="tool" value="${(step.tool || "analysis").replace(/"/g, "&quot;")}" />
          `;
          wizardStepsEl.appendChild(row);
        });
        wizardStepsEl.querySelectorAll("input[data-step]").forEach((node) => {
          node.addEventListener("input", (ev) => {
            if (!wizardDraft) return;
            const stepIndex = Number(ev.target.dataset.step);
            const field = ev.target.dataset.field;
            wizardDraft.plan.steps[stepIndex][field] = ev.target.value;
          });
        });
      }

      function generateWizardDraft() {
        const domain = wizardDomainEl.value;
        const variant = wizardVariantEl.value;
        const pickedDomain = wizardTemplates.find((item) => item.domain === domain);
        const pickedVariant = pickedDomain?.variants?.[variant]?.content;
        if (!pickedVariant?.contract || !pickedVariant?.plan) return;

        const contract = JSON.parse(JSON.stringify(pickedVariant.contract));
        const plan = JSON.parse(JSON.stringify(pickedVariant.plan));
        const goal = wizardGoalEl.value.trim() || contract.goal || plan.task || "";
        const preset = wizardPresetEl.value || contract.preset || "team";

        contract.goal = goal;
        contract.domain = domain;
        contract.preset = preset;
        plan.task = goal;

        wizardDraft = { contract, plan };
        renderWizardSteps(plan);
      }

      async function loadCatalog() {
        const [templates, tools, cases] = await Promise.all([
          fetch("/templates").then((r) => r.json()),
          fetch("/tools").then((r) => r.json()),
          fetch("/cases").then((r) => r.json()).catch(() => ({ count: 0, datasets: [], domains: [] }))
        ]);

        wizardTemplates = templates.templates || [];

      function scheduleAutoEvaluate() { if (!autoRunEl.checked) return; if (autoTimer) clearTimeout(autoTimer); autoTimer = setTimeout(() => runEvaluation().catch((err) => { resultEl.textContent = `Error: ${err.message}`; }), 300); }

      async function loadCatalog() {
        const [templates, tools, cases] = await Promise.all([fetch("/templates").then((r) => r.json()), fetch("/tools").then((r) => r.json()), fetch("/cases").then((r) => r.json()).catch(() => ({ count: 0, datasets: [], domains: [] }))]);
        const options = [];
        (templates.templates || []).forEach((domain) => Object.entries(domain.variants || {}).forEach(([variant, body]) => { if (body.content?.contract && body.content?.plan) { options.push({ key: `${domain.domain}:${variant}`, contract: body.content.contract, plan: body.content.plan }); } }));
        templateSelectEl.innerHTML = options.map((opt) => `<option value="${opt.key}">${opt.key}</option>`).join("");
        templateSelectEl._options = options;

        wizardDomainEl.innerHTML = wizardTemplates
          .map((item) => `<option value="${item.domain}">${item.domain}</option>`)
          .join("");
        if (!wizardDomainEl.value && wizardTemplates.length) wizardDomainEl.value = wizardTemplates[0].domain;
        renderWizardVariantOptions();
        generateWizardDraft();
        knownTools = (tools.tools || []).map((item) => item.tool).filter(Boolean).sort();
        catalogEl.textContent = JSON.stringify({ templates: (templates.templates || []).length, tools: (tools.tools || []).length, cases_count: cases.count || 0, case_domains: cases.domains || [] }, null, 2);
        renderWhatIfEditors(JSON.parse(planEl.value));
      }

      async function loadPlugins() {
        const [marketplace, installed] = await Promise.all([
          fetch("/plugin_marketplace").then((r) => r.json()),
          fetch("/plugins").then((r) => r.json())
        ]);
        pluginMarketplaceEl.textContent = JSON.stringify(marketplace, null, 2);
        pluginManagerEl.textContent = JSON.stringify(installed, null, 2);
      }

      async function installPluginBundle() {
        const payload = {
          source_path: pluginSourceEl.value,
          plugin_dir: pluginTargetDirEl.value
        };
        const response = await fetch("/plugins/install", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify(payload)
        }).then((r) => r.json());
        pluginManagerEl.textContent = JSON.stringify(response, null, 2);
        await loadPlugins();
      }

      async function uninstallPluginBundle() {
        const response = await fetch("/plugins/uninstall", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({ source_path: pluginSourceEl.value })
        }).then((r) => r.json());
        pluginManagerEl.textContent = JSON.stringify(response, null, 2);
        await loadPlugins();
      }

      async function runEvaluation() {
        const contract = JSON.parse(contractEl.value);
        const plan = JSON.parse(planEl.value);
        renderDag(plan);
        const res = await fetch("/evaluate", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ contract, plan, include_summary: true, include_steps: true, include_telemetry: true, calibration_domain: contract.domain || null }) });
        const payload = await res.json();
        decisionEl.innerHTML = `${decisionBadge(payload.decision)} effective=${payload.effective_decision || "n/a"}`;
        resultEl.textContent = JSON.stringify({ trace_id: payload.trace_id, span_id: payload.span_id, summary: payload.summary, next_steps: payload.next_steps, telemetry: payload.telemetry }, null, 2);
        renderAggregate(payload.aggregate || {}); renderStepRationales(payload.steps || []); renderContributions(plan, payload.steps || [], payload.aggregate || {});
      }

      function buildStreamingEvents(plan) {
        const steps = plan.steps || [];
        if (!steps.length) return [];
        const candidateIndex = Math.max(0, steps.length - 1);
        const candidate = steps[candidateIndex];
        const intensified = {
          ...candidate,
          description: `${candidate.description || "Step"} with broader production impact and uncertain dependencies`,
          tool_category: candidate.tool_category || "prod"
        };
        const reviewStepId = `review-${candidate.id || "step"}`;
        const reviewDepends = candidate.id ? [candidate.id] : [];
        return [
          {
            event_id: "stream-update-main-step",
            operation: "update_step",
            step_id: String(candidate.id || "1"),
            step: intensified,
            context: { label: "Intensify current step scope" }
          },
          {
            event_id: "stream-add-safety-review",
            operation: "add_step",
            step_id: reviewStepId,
            step: {
              id: reviewStepId,
              description: "Add expanded rollback + post-deploy validation rationale",
              tool: "pytest",
              depends_on: reviewDepends
            },
            context: { label: "Add new validation step" }
          }
        ];
      }

      function summarizeStreaming(payload) {
        const snapshots = [payload.initial, ...(payload.updates || [])];
        const lines = [];
        const priorByAxis = {};
        snapshots.forEach((snapshot) => {
          lines.push(`${snapshot.event_index}. ${snapshot.event_id} (${snapshot.operation}) => ${snapshot.decision}`);
          Object.entries(snapshot.aggregate || {})
            .sort((a, b) => b[1] - a[1])
            .slice(0, 3)
            .forEach(([axis, value]) => {
              const previous = priorByAxis[axis];
              const change = previous == null ? "" : ` (Δ ${(Number(value) - Number(previous)).toFixed(3)})`;
              lines.push(`   • ${axis}: ${Number(value).toFixed(3)}${change}`);
              priorByAxis[axis] = Number(value);
            });

          (snapshot.triggers || []).forEach((trigger) => {
            if (trigger.kind === "threshold_crossed") {
              lines.push(
                `   ⚠ threshold crossed on ${trigger.axis}: ${Number(trigger.previous || 0).toFixed(3)} -> ${Number(trigger.current || 0).toFixed(3)} (limit ${Number(trigger.threshold || 0).toFixed(3)})`
              );
            } else {
              lines.push(`   ↻ ${trigger.details || trigger.kind}`);
            }
          });

          (snapshot.judge_output_deltas || []).forEach((stepDelta) => {
            lines.push(`   Δ judge output for ${stepDelta.step_id}: ${stepDelta.changed_axes.join(", ") || "none"}`);
            (stepDelta.axis_deltas || []).forEach((axisDelta) => {
              const prevR = axisDelta.previous_rationale || "";
              const currR = axisDelta.current_rationale || "";
              if (prevR !== currR) {
                lines.push(`      rationale[${axisDelta.axis}]: "${prevR}" -> "${currR}"`);
              }
            });
          });
        });
        return lines.join("\n");
      }

      async function runStreamingEvaluation() {
        const contract = JSON.parse(contractEl.value);
        const plan = JSON.parse(planEl.value);
        const events = buildStreamingEvents(plan);
        const payload = await fetch("/evaluate_stream", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({
            contract,
            plan,
            events,
            include_steps: false,
            judge: "llm"
          })
        }).then((r) => r.json());

        streamingEl.textContent = summarizeStreaming(payload);
      }

      async function replayTelemetry() {
        const replay = await fetch("/telemetry/replay?limit=25").then((r) => r.json());
        telemetryEl.textContent = JSON.stringify(replay, null, 2);
      }

      async function runSessionEvaluation() {
        const body = sessionPayloadFromState();
        sessionPayloadEl.textContent = JSON.stringify(body, null, 2);
        const res = await fetch("/evaluate_session", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify(body) });
        const payload = await res.json();
        sessionDecisionEl.innerHTML = `${decisionBadge(payload.decision)} multi-agent governance result`;
        sessionResultEl.textContent = JSON.stringify({ decision: payload.decision, trace_id: payload.trace_id, negotiation: payload.negotiation }, null, 2);
        renderSessionDashboard(payload);
      }

      async function loadCalibrationDashboard() {
        const dashboard = await fetch("/calibration/dashboard").then((r) => r.json());
        calibrationDashboardState = dashboard;
        calibrationDashboardEl.textContent = JSON.stringify(dashboard, null, 2);
        calibrationDomainEl.innerHTML = (dashboard.domains || []).map((entry) => `<option value="${entry.domain}">${entry.domain}</option>`).join("");
        if (!calibrationSelection.domain && dashboard.domains?.length) calibrationSelection.domain = dashboard.domains[0].domain;
        if (calibrationSelection.domain) calibrationDomainEl.value = calibrationSelection.domain;
        renderCalibrationViews();
      }



      function renderCalibrationControls(entry) {
        calibrationControlsEl.innerHTML = "";
        const calibration = entry?.calibration || {};
        const scales = calibration.axis_scale || {};
        const factors = calibration.axis_threshold_factor || {};
        Object.keys(scales).forEach((axis) => {
          const wrap = document.createElement("div");
          wrap.className = "card";
          const scaleVal = Number(calibrationSelection.axisScaleDelta[axis] || 0);
          const factorVal = Number(calibrationSelection.axisThresholdFactorDelta[axis] || 0);
          wrap.innerHTML = `<h4>${axis}</h4>
            <label>Axis scale Δ <input type="range" min="-0.35" max="0.35" step="0.01" value="${scaleVal}" data-kind="scale" data-axis="${axis}" /><span class="muted">${scaleVal.toFixed(2)}</span></label>
            <label>Threshold factor Δ <input type="range" min="-0.35" max="0.35" step="0.01" value="${factorVal}" data-kind="threshold" data-axis="${axis}" /><span class="muted">${factorVal.toFixed(2)}</span></label>
            <p class="muted">Current scale=${Number(scales[axis] || 1).toFixed(2)}, threshold factor=${Number(factors[axis] || 1).toFixed(2)}</p>`;
          calibrationControlsEl.appendChild(wrap);
        });
        const abstainWrap = document.createElement("div");
        abstainWrap.className = "card";
        abstainWrap.innerHTML = `<h4>Uncertainty abstain threshold</h4><label>Δ <input type="range" min="-0.2" max="0.2" step="0.01" value="${Number(calibrationSelection.abstainDelta || 0)}" id="calibration-abstain" /><span class="muted">${Number(calibrationSelection.abstainDelta || 0).toFixed(2)}</span></label>`;
        calibrationControlsEl.appendChild(abstainWrap);

        calibrationControlsEl.querySelectorAll("input[data-kind]").forEach((node) => {
          node.addEventListener("input", (ev) => {
            const axis = ev.target.dataset.axis;
            const val = Number(ev.target.value || 0);
            if (ev.target.dataset.kind === "scale") calibrationSelection.axisScaleDelta[axis] = val;
            else calibrationSelection.axisThresholdFactorDelta[axis] = val;
            renderCalibrationViews();
          });
        });
        const abstainNode = el("calibration-abstain");
        if (abstainNode) {
          abstainNode.addEventListener("input", (ev) => {
            calibrationSelection.abstainDelta = Number(ev.target.value || 0);
            renderCalibrationViews();
          });
        }
      }

      function renderCalibrationViews() {
        if (!calibrationDashboardState?.domains?.length) return;
        const domain = calibrationSelection.domain || calibrationDashboardState.domains[0].domain;
        const entry = calibrationDashboardState.domains.find((item) => item.domain === domain) || calibrationDashboardState.domains[0];
        calibrationSelection.domain = entry.domain;
        const dist = entry.calibration?.axis_distributions || {};
        const rates = entry.calibration?.rates || {};
        const telemetryDelta = entry.calibration?.telemetry_delta || {};
        const thresholdBlock = entry.calibration?.preset_thresholds || {};

        const distLines = Object.entries(dist).map(([axis, item]) => `${axis}: n=${item.samples}, p50=${Number(item.quantiles?.p50 || 0).toFixed(2)}, p90=${Number(item.quantiles?.p90 || 0).toFixed(2)}
  bins=${(item.histogram || []).join(",")}`);
        calibrationDistributionsEl.textContent = distLines.join("\n\n") || "No data";

        const rateLines = Object.entries(rates).map(([axis, item]) => {
          const tele = telemetryDelta[axis] || {};
          return `${axis}: false_alarm=${(100 * Number(item.false_alarm_rate || 0)).toFixed(1)}%, override=${(100 * Number(item.override_rate || 0)).toFixed(1)}%, scaleΔ=${Number(tele.axis_scale_delta || 0).toFixed(3)}, thresholdΔ=${Number(tele.threshold_factor_delta || 0).toFixed(3)}`;
        });
        calibrationRatesEl.textContent = rateLines.join("\n") || "No data";
        calibrationThresholdsEl.textContent = JSON.stringify(thresholdBlock, null, 2);

        const preset = calibrationPlanPresetEl.value || "team";
        const base = thresholdBlock.base?.[preset] || {};
        const calibrated = thresholdBlock.calibrated?.[preset] || {};
        const impactLines = Object.keys(base).map((axis) => {
          const localFactor = 1 + Number(calibrationSelection.axisThresholdFactorDelta[axis] || 0);
          const adjustedThreshold = Math.max(0, Math.min(1, Number(calibrated[axis] || base[axis] || 0) * localFactor));
          const planAxis = Number((JSON.parse(planEl.value).steps || []).length ? 0.35 : 0);
          const ratio = adjustedThreshold > 0 ? (planAxis / adjustedThreshold) : 0;
          return `${axis}: threshold=${adjustedThreshold.toFixed(3)} | sample_plan_score≈${planAxis.toFixed(3)} | pressure=${ratio.toFixed(2)}x`;
        });
        calibrationPlanImpactEl.textContent = impactLines.join("\n");
        renderCalibrationControls(entry);
      }
      async function validateCaseDraft() {
        const payload = { case: JSON.parse(caseDraftEl.value) };
        const res = await fetch("/dataset/validate", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify(payload)
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.detail || JSON.stringify(data));
        datasetOutputEl.textContent = `Validation OK for case: ${data.case_id}`;
      }

      async function suggestCaseVectors() {
        const contract = JSON.parse(contractEl.value);
        const plan = JSON.parse(planEl.value);
        const draft = JSON.parse(caseDraftEl.value);
        const payload = {
          id: draft.id || "community_case_001",
          domain: draft.domain || "engineering",
          instruction: draft.instruction || contract.goal || "Community contribution",
          contract,
          plan,
          expected_decision: draft.expected_decision || "ALLOW",
          expected_rationale: draft.expected_rationale || "TBD",
          notes: draft.notes || null
        };
        const res = await fetch("/dataset/suggest", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify(payload)
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.detail || JSON.stringify(data));
        caseDraftEl.value = JSON.stringify(data.case, null, 2);
        datasetOutputEl.textContent = "Suggested vectors loaded into draft.";
      }

      el("load-template").addEventListener("click", () => {
        const picked = (templateSelectEl._options || []).find((opt) => opt.key === templateSelectEl.value);
        if (!picked) return;
        contractEl.value = JSON.stringify(picked.contract, null, 2);
        planEl.value = JSON.stringify(picked.plan, null, 2);
        renderDag(picked.plan);
        renderWhatIfEditors(picked.plan);
        scheduleAutoEvaluate();
      });
      el("run").addEventListener("click", () => runEvaluation().catch((err) => {
        resultEl.textContent = `Error: ${err.message}`;
      }));
      el("replay").addEventListener("click", () => replayTelemetry().catch((err) => {
        telemetryEl.textContent = `Error: ${err.message}`;
      }));
      el("calibration").addEventListener("click", () => loadCalibrationDashboard().catch((err) => {
        calibrationDashboardEl.textContent = `Error: ${err.message}`;
      }));
      calibrationDomainEl.addEventListener("change", (ev) => { calibrationSelection.domain = ev.target.value; renderCalibrationViews(); });
      calibrationPlanPresetEl.addEventListener("change", () => renderCalibrationViews());
      el("dataset-validate").addEventListener("click", () => validateCaseDraft().catch((err) => {
        datasetOutputEl.textContent = `Validation error: ${err.message}`;
      }));
      el("dataset-suggest").addEventListener("click", () => suggestCaseVectors().catch((err) => {
        datasetOutputEl.textContent = `Suggestion error: ${err.message}`;
      }));
      el("stream").addEventListener("click", () => runStreamingEvaluation().catch((err) => {
        streamingEl.textContent = `Error: ${err.message}`;
      }));
      el("run").addEventListener("click", () => runEvaluation().catch((err) => { resultEl.textContent = `Error: ${err.message}`; }));
      el("run-session").addEventListener("click", () => runSessionEvaluation().catch((err) => { sessionResultEl.textContent = `Error: ${err.message}`; }));
      el("replay").addEventListener("click", () => replayTelemetry().catch((err) => { telemetryEl.textContent = `Error: ${err.message}`; }));
      el("calibration").addEventListener("click", () => loadCalibrationDashboard().catch((err) => { calibrationDashboardEl.textContent = `Error: ${err.message}`; }));
      el("add-agent").addEventListener("click", () => {
        const idx = sessionState.agents.length + 1;
        sessionState.agents.push({ agent_id: `agent-${idx}`, plan: { task: `agent-${idx} task`, steps: [{ id: "1", description: "Describe step", tool: knownTools[0] || "analysis" }] } });
        renderSessionBuilder();
      });
      el("sync-from-current-plan").addEventListener("click", () => {
        const parsedPlan = JSON.parse(planEl.value);
        if (!sessionState.agents.length) sessionState.agents.push({ agent_id: "agent-1", plan: parsedPlan });
        else sessionState.agents[0].plan = parsedPlan;
        renderSessionBuilder();
      });
      ["session-budget-cost", "session-budget-time", "session-budget-tools"].forEach((id) => el(id).addEventListener("input", () => { sessionPayloadEl.textContent = JSON.stringify(sessionPayloadFromState(), null, 2); }));

      planEl.addEventListener("input", () => {
        try { const plan = JSON.parse(planEl.value); renderDag(plan); renderWhatIfEditors(plan); scheduleAutoEvaluate(); }
        catch (_err) { /* continue editing invalid JSON */ }
      });

      renderDag(defaultPlan);
      renderWhatIfEditors(defaultPlan);
      wizardDomainEl.addEventListener("change", () => {
        renderWizardVariantOptions();
        generateWizardDraft();
      });
      wizardVariantEl.addEventListener("change", () => generateWizardDraft());
      wizardGoalEl.addEventListener("input", () => generateWizardDraft());
      wizardPresetEl.addEventListener("change", () => generateWizardDraft());
      el("wizard-generate").addEventListener("click", () => generateWizardDraft());
      el("wizard-apply").addEventListener("click", () => {
        if (!wizardDraft) return;
        contractEl.value = JSON.stringify(wizardDraft.contract, null, 2);
        planEl.value = JSON.stringify(wizardDraft.plan, null, 2);
        renderDag(wizardDraft.plan);
        renderWhatIfEditors(wizardDraft.plan);
        scheduleAutoEvaluate();
      });

      loadCatalog().then(() => runEvaluation()).catch((err) => {
        catalogEl.textContent = `Catalog load error: ${err.message}`;
      });
      loadCalibrationDashboard().catch((err) => {
        calibrationDashboardEl.textContent = `Calibration load error: ${err.message}`;
      });
      runStreamingEvaluation().catch((err) => {
        streamingEl.textContent = `Streaming load error: ${err.message}`;
      });
      runEvaluation().catch((err) => {
        resultEl.textContent = `Error: ${err.message}`;
      });
      renderSessionBuilder();
      loadCatalog().catch((err) => { catalogEl.textContent = `Catalog load error: ${err.message}`; });
      loadCalibrationDashboard().catch((err) => { calibrationDashboardEl.textContent = `Calibration load error: ${err.message}`; });
      runEvaluation().catch((err) => { resultEl.textContent = `Error: ${err.message}`; });
      runSessionEvaluation().catch((err) => { sessionResultEl.textContent = `Error: ${err.message}`; });
    }
    </script>
  </body>
</html>
