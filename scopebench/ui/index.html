<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ScopeBench UI</title>
    <style>
      :root {
        color-scheme: light;
        font-family: Inter, Arial, sans-serif;
      }
      body {
        margin: 0;
        background: #f3f5f8;
        color: #111827;
      }
      main {
        max-width: 1200px;
        margin: 24px auto;
        padding: 0 16px 32px;
      }
      h1, h2, h3 {
        margin: 0 0 8px;
      }
      p {
        margin: 4px 0 12px;
      }
      .grid {
        display: grid;
        gap: 16px;
      }
      .two-col {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
      .card {
        background: #fff;
        border: 1px solid #d1d5db;
        border-radius: 10px;
        padding: 14px;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04);
      }
      textarea, pre, select {
        width: 100%;
        box-sizing: border-box;
        font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      }
      textarea {
        min-height: 180px;
        border: 1px solid #cbd5e1;
        border-radius: 8px;
        padding: 8px;
      }
      pre {
        margin: 0;
        background: #0f172a;
        color: #f8fafc;
        border-radius: 8px;
        padding: 10px;
        overflow-x: auto;
        min-height: 120px;
      }
      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
      }
      button {
        border: 1px solid #2563eb;
        background: #2563eb;
        color: #fff;
        border-radius: 8px;
        padding: 8px 12px;
        cursor: pointer;
      }
      button.secondary {
        border-color: #64748b;
        background: #64748b;
      }
      .badge {
        display: inline-block;
        border-radius: 999px;
        padding: 2px 8px;
        font-size: 12px;
        margin-right: 8px;
      }
      .allow { background: #dcfce7; color: #166534; }
      .ask { background: #fef3c7; color: #92400e; }
      .deny { background: #fee2e2; color: #991b1b; }
      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 14px;
      }
      input[type="range"] { width: 100%; }
      .muted { color: #64748b; font-size: 12px; }
      .step-editor {
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        padding: 10px;
        margin-bottom: 10px;
      }
      .slider-grid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px 12px;
      }
      .slider-row {
        padding: 6px;
        border: 1px solid #e5e7eb;
        border-radius: 6px;
      }
      .inline-label {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }
      th, td {
        border-bottom: 1px solid #e5e7eb;
        padding: 6px;
        text-align: left;
        vertical-align: top;
      }
      @media (max-width: 900px) {
        .two-col { grid-template-columns: 1fr; }
      }
    </style>
  </head>
  <body>
    <main>
      <h1>ScopeBench Interactive Workbench</h1>
      <p>Author contracts and plans, inspect DAGs, view axis scores/rationales, and replay telemetry.</p>

      <div class="card">
        <div class="controls">
          <button id="load-template" class="secondary">Load template</button>
          <select id="template-select"></select>
          <button id="run">Run /evaluate</button>
          <button id="replay" class="secondary">Replay telemetry</button>
          <label><input id="auto-run" type="checkbox" checked /> auto-run what-if</label>
        </div>
      </div>

      <section class="grid two-col" style="margin-top: 16px">
        <div class="card">
          <h3>Contract (JSON)</h3>
          <textarea id="contract"></textarea>
        </div>
        <div class="card">
          <h3>Plan (JSON)</h3>
          <textarea id="plan"></textarea>
        </div>
      </section>

      <section class="grid two-col" style="margin-top: 16px">
        <div class="card">
          <h3>Plan DAG</h3>
          <pre id="dag"></pre>
        </div>
        <div class="card">
          <h3>Decision & Trace</h3>
          <div id="decision"></div>
          <pre id="result"></pre>
        </div>
      </section>

      <section class="grid two-col" style="margin-top: 16px">
        <div class="card">
          <h3>Axis Scores</h3>
          <table>
            <thead><tr><th>Axis</th><th>Score</th></tr></thead>
            <tbody id="axis-table"></tbody>
          </table>
        </div>
        <div class="card">
          <h3>Per-axis Rationales (LLM Judge + rules)</h3>
          <table>
            <thead><tr><th>Step</th><th>Axis</th><th>Score</th><th>Confidence</th><th>Rationale</th></tr></thead>
            <tbody id="rationale-table"></tbody>
          </table>
        </div>
      </section>

      <section class="card" style="margin-top: 16px">
        <h3>Explainability: Aggregate Risk Contributions</h3>
        <p class="muted">Shows each step's contribution along the dominant risk path per axis.</p>
        <table>
          <thead><tr><th>Axis</th><th>Aggregate</th><th>Critical path terminal</th><th>Step contributions</th></tr></thead>
          <tbody id="contrib-table"></tbody>
        </table>
      </section>

      <section class="card" style="margin-top: 16px">
        <h3>What-if Lab</h3>
        <p class="muted">Adjust descriptions, tools, and effect magnitudes. Updates flow into plan JSON and re-evaluate automatically.</p>
        <div id="whatif-editors"></div>
      </section>

      <section class="grid two-col" style="margin-top: 16px">
        <div class="card">
          <h3>Catalog</h3>
          <pre id="catalog"></pre>
        </div>
        <div class="card">
          <h3>Telemetry Replay</h3>
          <pre id="telemetry"></pre>
        </div>
      </section>
    </main>

    <script>
      const defaultContract = { goal: "Fix flaky CI test", preset: "team" };
      const defaultPlan = {
        task: "Fix flaky CI test",
        steps: [
          { id: "1", description: "Inspect failing test", tool: "git_read" },
          { id: "2", description: "Patch timing", tool: "git_patch", depends_on: ["1"] },
          { id: "3", description: "Run pytest", tool: "pytest", depends_on: ["2"] }
        ]
      };

      const el = (id) => document.getElementById(id);
      const contractEl = el("contract");
      const planEl = el("plan");
      const dagEl = el("dag");
      const resultEl = el("result");
      const decisionEl = el("decision");
      const axisTableEl = el("axis-table");
      const rationaleTableEl = el("rationale-table");
      const contribTableEl = el("contrib-table");
      const whatIfEditorsEl = el("whatif-editors");
      const catalogEl = el("catalog");
      const telemetryEl = el("telemetry");
      const templateSelectEl = el("template-select");
      const autoRunEl = el("auto-run");
      const EFFECT_AXES = [
        ["resources", "resource_intensity"],
        ["legal", "legal_exposure"],
        ["stakeholders", "stakeholder_radius"],
        ["irreversible_actions", "irreversibility"],
        ["geo_scope", "spatial"],
        ["time_horizon", "temporal"]
      ];
      const MAGNITUDE = ["none", "low", "medium", "high", "extreme"];
      let knownTools = [];
      let autoTimer = null;

      contractEl.value = JSON.stringify(defaultContract, null, 2);
      planEl.value = JSON.stringify(defaultPlan, null, 2);

      function renderDag(plan) {
        const nodes = (plan.steps || []).map((s) => `${s.id} [${s.tool || "none"}]`).join("\n");
        const edges = (plan.steps || [])
          .flatMap((s) => (s.depends_on || []).map((dep) => `${dep} -> ${s.id}`))
          .join("\n");
        dagEl.textContent = `nodes:\n${nodes || "(none)"}\n\nedges:\n${edges || "(none)"}`;
      }

      function renderAggregate(aggregate = {}) {
        axisTableEl.innerHTML = "";
        Object.entries(aggregate)
          .sort((a, b) => b[1] - a[1])
          .forEach(([axis, score]) => {
            const tr = document.createElement("tr");
            tr.innerHTML = `<td>${axis}</td><td>${Number(score).toFixed(3)}</td>`;
            axisTableEl.appendChild(tr);
          });
      }

      function renderStepRationales(steps = []) {
        rationaleTableEl.innerHTML = "";
        const rows = [];
        steps.forEach((step) => {
          Object.entries(step.axes || {}).forEach(([axis, detail]) => {
            rows.push({ step: step.step_id || "unknown", axis, ...detail });
          });
        });
        rows
          .sort((a, b) => b.value - a.value)
          .forEach((row) => {
            const tr = document.createElement("tr");
            tr.innerHTML = `<td>${row.step}</td><td>${row.axis}</td><td>${Number(row.value).toFixed(3)}</td><td>${Number(row.confidence || 0).toFixed(2)}</td><td>${row.rationale || "n/a"}</td>`;
            rationaleTableEl.appendChild(tr);
          });
      }

      function decisionBadge(decision) {
        const normalized = String(decision || "").toLowerCase();
        const cls = normalized === "allow" ? "allow" : normalized === "ask" ? "ask" : "deny";
        return `<span class="badge ${cls}">${decision || "UNKNOWN"}</span>`;
      }

      function toMagnitude(v) {
        const idx = Math.max(0, Math.min(MAGNITUDE.length - 1, Math.round(Number(v || 0) * 4)));
        return MAGNITUDE[idx];
      }

      function topoOrder(plan) {
        const remaining = {};
        (plan.steps || []).forEach((s) => {
          remaining[s.id] = [...(s.depends_on || [])];
        });
        const ready = (plan.steps || []).filter((s) => !(s.depends_on || []).length).map((s) => s.id);
        const order = [];
        while (ready.length) {
          const node = ready.pop();
          order.push(node);
          Object.entries(remaining).forEach(([stepId, deps]) => {
            const idx = deps.indexOf(node);
            if (idx >= 0) {
              deps.splice(idx, 1);
              if (!deps.length && !order.includes(stepId) && !ready.includes(stepId)) ready.push(stepId);
            }
          });
        }
        return order;
      }

      function computeContributions(plan, steps, aggregate = {}) {
        const axes = Object.keys(aggregate || {});
        const vectors = {};
        (steps || []).forEach((step) => {
          vectors[step.step_id] = Object.fromEntries(
            Object.entries(step.axes || {}).map(([axis, detail]) => [axis, Number(detail.value || 0)])
          );
        });
        const predecessors = Object.fromEntries((plan.steps || []).map((s) => [s.id, s.depends_on || []]));
        const order = topoOrder(plan);
        const pathScope = {};
        const parentByAxis = {};
        const deltaByAxis = {};
        order.forEach((stepId) => {
          pathScope[stepId] = {};
          parentByAxis[stepId] = {};
          deltaByAxis[stepId] = {};
          axes.forEach((axis) => {
            let baseline = 0;
            let winnerPred = null;
            (predecessors[stepId] || []).forEach((pred) => {
              const predValue = pathScope[pred]?.[axis] ?? 0;
              if (predValue >= baseline) {
                baseline = predValue;
                winnerPred = pred;
              }
            });
            const stepAxis = vectors[stepId]?.[axis] ?? 0;
            const updated = Math.max(baseline, stepAxis);
            pathScope[stepId][axis] = updated;
            parentByAxis[stepId][axis] = winnerPred;
            deltaByAxis[stepId][axis] = Math.max(0, updated - baseline);
          });
        });
        return axes.map((axis) => {
          const agg = Number(aggregate[axis] || 0);
          let terminal = null;
          order.forEach((stepId) => {
            if ((pathScope[stepId]?.[axis] ?? 0) >= (pathScope[terminal]?.[axis] ?? -1)) {
              terminal = stepId;
            }
          });
          const contributions = [];
          let cursor = terminal;
          while (cursor) {
            const delta = Number(deltaByAxis[cursor]?.[axis] || 0);
            if (delta > 0 || cursor === terminal) contributions.push({ stepId: cursor, delta });
            cursor = parentByAxis[cursor]?.[axis] || null;
          }
          contributions.reverse();
          const text = contributions
            .map((c) => `${c.stepId}: ${(agg > 0 ? (100 * c.delta) / agg : 0).toFixed(1)}% (${c.delta.toFixed(3)})`)
            .join(" â†’ ");
          return { axis, aggregate: agg, terminal, text: text || "(none)" };
        });
      }

      function renderContributions(plan, steps, aggregate) {
        contribTableEl.innerHTML = "";
        computeContributions(plan, steps, aggregate)
          .sort((a, b) => b.aggregate - a.aggregate)
          .forEach((entry) => {
            const tr = document.createElement("tr");
            tr.innerHTML = `<td>${entry.axis}</td><td>${entry.aggregate.toFixed(3)}</td><td>${entry.terminal || "n/a"}</td><td>${entry.text}</td>`;
            contribTableEl.appendChild(tr);
          });
      }

      function scheduleAutoEvaluate() {
        if (!autoRunEl.checked) return;
        if (autoTimer) clearTimeout(autoTimer);
        autoTimer = setTimeout(() => runEvaluation().catch((err) => {
          resultEl.textContent = `Error: ${err.message}`;
        }), 300);
      }

      function updatePlanField(stepIndex, field, value) {
        const plan = JSON.parse(planEl.value);
        plan.steps[stepIndex][field] = value;
        planEl.value = JSON.stringify(plan, null, 2);
        renderDag(plan);
        scheduleAutoEvaluate();
      }

      function updateEffectMagnitude(stepIndex, effectKey, value) {
        const plan = JSON.parse(planEl.value);
        const step = plan.steps[stepIndex];
        step.effects = step.effects || { version: "effects_v1", macro_consequences: [] };
        step.effects[effectKey] = {
          ...(step.effects[effectKey] || {}),
          magnitude: toMagnitude(value),
          rationale: "adjusted in what-if lab"
        };
        if (!step.effects.version) step.effects.version = "effects_v1";
        planEl.value = JSON.stringify(plan, null, 2);
        scheduleAutoEvaluate();
      }

      function sliderValueFor(step, effectKey) {
        const mag = step.effects?.[effectKey]?.magnitude;
        const idx = MAGNITUDE.indexOf(mag);
        return idx >= 0 ? idx / 4 : 0;
      }

      function renderWhatIfEditors(plan) {
        whatIfEditorsEl.innerHTML = "";
        (plan.steps || []).forEach((step, stepIndex) => {
          const container = document.createElement("div");
          container.className = "step-editor";
          const options = knownTools
            .map((tool) => `<option value="${tool}" ${step.tool === tool ? "selected" : ""}>${tool}</option>`)
            .join("");
          const sliders = EFFECT_AXES.map(([effectKey, axisKey]) => {
            const value = sliderValueFor(step, effectKey);
            const id = `${step.id}-${effectKey}`;
            return `<div class="slider-row"><div class="inline-label"><label for="${id}">${axisKey}</label><span class="muted">${toMagnitude(value)}</span></div><input id="${id}" data-step="${stepIndex}" data-effect="${effectKey}" type="range" min="0" max="1" step="0.25" value="${value}" /></div>`;
          }).join("");
          container.innerHTML = `
            <h4>${step.id}</h4>
            <label>Description</label>
            <textarea data-field="description" data-step="${stepIndex}" style="min-height:72px">${step.description || ""}</textarea>
            <label>Tool</label>
            <select data-field="tool" data-step="${stepIndex}">${options}</select>
            <div class="slider-grid" style="margin-top:10px">${sliders}</div>
          `;
          whatIfEditorsEl.appendChild(container);
        });

        whatIfEditorsEl.querySelectorAll("textarea[data-field], select[data-field]").forEach((node) => {
          node.addEventListener("input", (ev) => {
            const stepIndex = Number(ev.target.dataset.step);
            const field = ev.target.dataset.field;
            updatePlanField(stepIndex, field, ev.target.value);
          });
        });
        whatIfEditorsEl.querySelectorAll("input[type='range']").forEach((node) => {
          node.addEventListener("input", (ev) => {
            const value = Number(ev.target.value);
            ev.target.previousElementSibling.querySelector("span").textContent = toMagnitude(value);
            updateEffectMagnitude(Number(ev.target.dataset.step), ev.target.dataset.effect, value);
          });
        });
      }

      async function loadCatalog() {
        const [templates, tools, cases] = await Promise.all([
          fetch("/templates").then((r) => r.json()),
          fetch("/tools").then((r) => r.json()),
          fetch("/cases").then((r) => r.json()).catch(() => ({ count: 0, datasets: [], domains: [] }))
        ]);

        const options = [];
        (templates.templates || []).forEach((domain) => {
          Object.entries(domain.variants || {}).forEach(([variant, body]) => {
            if (body.content?.contract && body.content?.plan) {
              const key = `${domain.domain}:${variant}`;
              options.push({ key, contract: body.content.contract, plan: body.content.plan });
            }
          });
        });
        templateSelectEl.innerHTML = options
          .map((opt) => `<option value="${opt.key}">${opt.key}</option>`)
          .join("");
        templateSelectEl._options = options;
        knownTools = (tools.tools || []).map((item) => item.tool).filter(Boolean).sort();

        catalogEl.textContent = JSON.stringify(
          {
            templates: (templates.templates || []).length,
            tools: (tools.tools || []).length,
            cases_count: cases.count || 0,
            case_domains: cases.domains || []
          },
          null,
          2
        );
        renderWhatIfEditors(JSON.parse(planEl.value));
      }

      async function runEvaluation() {
        const contract = JSON.parse(contractEl.value);
        const plan = JSON.parse(planEl.value);
        renderDag(plan);

        const res = await fetch("/evaluate", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({
            contract,
            plan,
            include_summary: true,
            include_steps: true,
            include_telemetry: true
          })
        });
        const payload = await res.json();

        decisionEl.innerHTML = `${decisionBadge(payload.decision)} effective=${payload.effective_decision || "n/a"}`;
        resultEl.textContent = JSON.stringify(
          {
            trace_id: payload.trace_id,
            span_id: payload.span_id,
            summary: payload.summary,
            next_steps: payload.next_steps,
            telemetry: payload.telemetry
          },
          null,
          2
        );
        renderAggregate(payload.aggregate || {});
        renderStepRationales(payload.steps || []);
        renderContributions(plan, payload.steps || [], payload.aggregate || {});
      }

      async function replayTelemetry() {
        const replay = await fetch("/telemetry/replay?limit=25").then((r) => r.json());
        telemetryEl.textContent = JSON.stringify(replay, null, 2);
      }

      el("load-template").addEventListener("click", () => {
        const picked = (templateSelectEl._options || []).find((opt) => opt.key === templateSelectEl.value);
        if (!picked) return;
        contractEl.value = JSON.stringify(picked.contract, null, 2);
        planEl.value = JSON.stringify(picked.plan, null, 2);
        renderDag(picked.plan);
        renderWhatIfEditors(picked.plan);
        scheduleAutoEvaluate();
      });
      el("run").addEventListener("click", () => runEvaluation().catch((err) => {
        resultEl.textContent = `Error: ${err.message}`;
      }));
      el("replay").addEventListener("click", () => replayTelemetry().catch((err) => {
        telemetryEl.textContent = `Error: ${err.message}`;
      }));
      planEl.addEventListener("input", () => {
        try {
          const plan = JSON.parse(planEl.value);
          renderDag(plan);
          renderWhatIfEditors(plan);
          scheduleAutoEvaluate();
        } catch (_err) {
          // continue editing invalid JSON
        }
      });

      renderDag(defaultPlan);
      renderWhatIfEditors(defaultPlan);
      loadCatalog().catch((err) => {
        catalogEl.textContent = `Catalog load error: ${err.message}`;
      });
      runEvaluation().catch((err) => {
        resultEl.textContent = `Error: ${err.message}`;
      });
    </script>
  </body>
</html>
