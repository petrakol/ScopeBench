<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ScopeBench UI</title>
    <style>
      :root { color-scheme: light; font-family: Inter, Arial, sans-serif; }
      body { margin: 0; background: #f3f5f8; color: #111827; }
      main { max-width: 1200px; margin: 24px auto; padding: 0 16px 32px; }
      h1, h2, h3 { margin: 0 0 8px; }
      p { margin: 4px 0 12px; }
      .grid { display: grid; gap: 16px; }
      .two-col { grid-template-columns: repeat(2, minmax(0, 1fr)); }
      .three-col { grid-template-columns: repeat(3, minmax(0, 1fr)); }
      .card { background: #fff; border: 1px solid #d1d5db; border-radius: 10px; padding: 14px; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04); }
      textarea, pre, select, input[type="text"], input[type="number"] { width: 100%; box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
      textarea { min-height: 180px; border: 1px solid #cbd5e1; border-radius: 8px; padding: 8px; }
      pre { margin: 0; background: #0f172a; color: #f8fafc; border-radius: 8px; padding: 10px; overflow-x: auto; min-height: 120px; }
      .controls { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
      button { border: 1px solid #2563eb; background: #2563eb; color: #fff; border-radius: 8px; padding: 8px 12px; cursor: pointer; }
      button.secondary { border-color: #64748b; background: #64748b; }
      .badge { display: inline-block; border-radius: 999px; padding: 2px 8px; font-size: 12px; margin-right: 8px; }
      .allow { background: #dcfce7; color: #166534; }
      .ask { background: #fef3c7; color: #92400e; }
      .deny { background: #fee2e2; color: #991b1b; }
      table { width: 100%; border-collapse: collapse; font-size: 14px; }
      input[type="range"] { width: 100%; }
      .muted { color: #64748b; font-size: 12px; }
      .step-editor {
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        padding: 10px;
        margin-bottom: 10px;
      }
      .slider-grid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px 12px;
      }
      .slider-row {
        padding: 6px;
        border: 1px solid #e5e7eb;
        border-radius: 6px;
      }
      .effect-row-header {
        display: grid;
        grid-template-columns: auto 1fr auto;
        align-items: center;
        gap: 8px;
      }
      .effect-row-rank {
        display: inline-flex;
        width: 22px;
        height: 22px;
        border-radius: 999px;
        background: #e2e8f0;
        color: #0f172a;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: 600;
      }
      .axis-order-controls {
        display: inline-flex;
        gap: 6px;
      }
      .axis-order-controls button {
        padding: 2px 8px;
        border-radius: 6px;
        font-size: 12px;
      }
      .inline-label {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }
      th, td {
        border-bottom: 1px solid #e5e7eb;
        padding: 6px;
        text-align: left;
        vertical-align: top;
      }
      .wizard-grid {
        display: grid;
        grid-template-columns: repeat(4, minmax(0, 1fr));
        gap: 8px;
      }
      .wizard-grid input,
      .wizard-grid select {
        width: 100%;
        box-sizing: border-box;
        padding: 8px;
        border: 1px solid #cbd5e1;
        border-radius: 8px;
      }
      .step-list {
        margin-top: 10px;
        display: grid;
        gap: 8px;
      }
      .wizard-step {
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        padding: 8px;
        display: grid;
        grid-template-columns: 110px minmax(0, 1fr) 180px;
        gap: 8px;
        align-items: center;
      }
      .case-explorer-controls {
        display: grid;
        grid-template-columns: 2fr 1fr 1fr;
        gap: 8px;
        margin-bottom: 10px;
      }
      .case-list {
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        max-height: 360px;
        overflow: auto;
      }
      .case-item {
        padding: 10px;
        border-bottom: 1px solid #e5e7eb;
        cursor: pointer;
      }
      .case-item:last-child { border-bottom: none; }
      .case-item.active { background: #eff6ff; }
      .case-item:hover { background: #f8fafc; }
      .bar-chart { display: grid; gap: 8px; }
      .bar-row { display: grid; grid-template-columns: 120px minmax(0, 1fr) 72px; gap: 8px; align-items: center; }
      .bar-track { height: 12px; border-radius: 999px; background: #e2e8f0; overflow: hidden; }
      .bar-fill { display: block; height: 100%; background: linear-gradient(90deg, #60a5fa, #2563eb); }
      .rate-grid { display: grid; gap: 8px; }
      .rate-card { border: 1px solid #e5e7eb; border-radius: 8px; padding: 8px; }
      .threshold-table td, .threshold-table th { font-size: 12px; }
      .dataset-wizard-steps {
        display: grid;
        gap: 8px;
        margin: 10px 0;
      }
      .dataset-wizard-step {
        display: grid;
        grid-template-columns: 24px 1fr auto;
        gap: 8px;
        align-items: center;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        padding: 8px;
      }
      .status-chip {
        border-radius: 999px;
        font-size: 12px;
        padding: 2px 8px;
        border: 1px solid #cbd5e1;
        background: #f8fafc;
        color: #334155;
      }
      .status-chip.done { background: #dcfce7; color: #166534; border-color: #86efac; }
      .status-chip.running { background: #dbeafe; color: #1d4ed8; border-color: #93c5fd; }
      .status-chip.error { background: #fee2e2; color: #991b1b; border-color: #fca5a5; }
      @media (max-width: 900px) {
        .two-col { grid-template-columns: 1fr; }
      }
      .step-editor, .agent-editor { border: 1px solid #e5e7eb; border-radius: 8px; padding: 10px; margin-bottom: 10px; }
      .slider-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 8px 12px; }
      .slider-row { padding: 6px; border: 1px solid #e5e7eb; border-radius: 6px; }
      .inline-label { display: flex; justify-content: space-between; align-items: center; gap: 8px; }
      .field-grid { display: grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 8px; margin-bottom: 8px; }
      .agent-header { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 8px; }
      .agent-header input[type="text"] { flex: 1; }
      .ledger-grid { display: grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 10px; }
      .ledger-card { border: 1px solid #dbeafe; background: #eff6ff; border-radius: 8px; padding: 8px; }
      .meter { height: 8px; background: #e5e7eb; border-radius: 999px; overflow: hidden; margin-top: 4px; }
      .meter > span { display: block; height: 100%; background: #2563eb; }
      .signal-chip { display: inline-block; margin-right: 6px; margin-bottom: 6px; padding: 3px 8px; border-radius: 999px; font-size: 12px; background: #fee2e2; color: #991b1b; }
      .chart-block { border: 1px solid #e5e7eb; border-radius: 8px; padding: 8px; margin-top: 8px; }
      .chart-title { font-weight: 600; margin-bottom: 6px; }
      .bar-row { display: grid; grid-template-columns: 140px minmax(0, 1fr) 64px; align-items: center; gap: 8px; margin-bottom: 6px; font-size: 13px; }
      .bar-track { height: 10px; border-radius: 999px; background: #e5e7eb; overflow: hidden; }
      .bar-fill { height: 100%; border-radius: 999px; }
      .bar-fill.budget { background: #2563eb; }
      .bar-fill.risk { background: #dc2626; }
      th, td { border-bottom: 1px solid #e5e7eb; padding: 6px; text-align: left; vertical-align: top; }
      @media (max-width: 900px) { .two-col, .three-col, .field-grid, .ledger-grid { grid-template-columns: 1fr; } }
    </style>
  </head>
  <body>
    <main>
      <h1>ScopeBench Interactive Workbench</h1>
      <p>Author contracts and plans, inspect DAGs, view axis scores/rationales, and replay telemetry.</p>

      <div class="card">
        <div class="controls">
          <button id="load-template" class="secondary">Load template</button>
          <select id="template-select"></select>
          <button id="run">Run /evaluate</button>
          <button id="run-session">Run /evaluate_session</button>
          <button id="replay" class="secondary">Replay telemetry</button>
          <button id="calibration" class="secondary">Calibration dashboard</button>
          <button id="cases-analytics" class="secondary">Cases analytics</button>
          <button id="dataset-validate" class="secondary">Validate case draft</button>
          <button id="dataset-suggest" class="secondary">Suggest vectors</button>
          <button id="stream" class="secondary">Stream /evaluate_stream</button>
          <button id="refresh-plugins" class="secondary">Refresh plugins</button>
          <label><input id="auto-run" type="checkbox" checked /> auto-run what-if</label>
        </div>
      </div>

      <section class="card" style="margin-top: 16px">
        <h3>Plan Generation Wizard</h3>
        <p class="muted">Pick a domain preset and variant, then generate/edit a baseline plan from templates.</p>
        <div class="wizard-grid">
          <input id="wizard-goal" placeholder="Goal (e.g., Stabilize flaky checkout tests)" />
          <select id="wizard-domain"></select>
          <select id="wizard-variant"></select>
          <select id="wizard-preset">
            <option value="">(template default)</option>
            <option value="team">team</option>
            <option value="enterprise">enterprise</option>
            <option value="regulated">regulated</option>
          </select>
        </div>
        <div class="controls" style="margin-top: 10px">
          <button id="wizard-generate" class="secondary">Generate baseline</button>
          <button id="wizard-apply">Apply to editor</button>
        </div>
        <div id="wizard-steps" class="step-list"></div>
      </section>

      <section class="grid two-col" style="margin-top: 16px">
        <div class="card">
          <h3>Contract (JSON)</h3>
          <textarea id="contract"></textarea>
        </div>
        <div class="card">
          <h3>Plan (JSON)</h3>
          <textarea id="plan"></textarea>
        </div>
      </section>

      <section class="grid two-col" style="margin-top: 16px">
        <div class="card">
          <h3>Plan DAG</h3>
          <pre id="dag"></pre>
        </div>
        <div class="card">
          <h3>Decision & Trace</h3>
          <div id="decision"></div>
          <pre id="result"></pre>
        </div>
      </section>

      <section class="grid two-col" style="margin-top: 16px">
        <div class="card">
          <h3>Axis Scores</h3>
          <table><thead><tr><th>Axis</th><th>Score</th></tr></thead><tbody id="axis-table"></tbody></table>
        </div>
        <div class="card">
          <h3>Per-axis Rationales (LLM Judge + rules)</h3>
          <table><thead><tr><th>Step</th><th>Axis</th><th>Score</th><th>Confidence</th><th>Rationale</th></tr></thead><tbody id="rationale-table"></tbody></table>
        </div>
      </section>

      <section class="card" style="margin-top: 16px">
        <h3>Effect-axis weighting and precedence lab</h3>
        <p class="muted">Tune axis weights, ordering, and signal precedence to run sensitivity analysis on a sample plan grounded in the effects guide.</p>
        <div class="field-grid">
          <label>Signal precedence mode
            <select id="effect-lab-mode">
              <option value="strict">Strict precedence (effects &gt; priors &gt; heuristics)</option>
              <option value="blend">Weighted blend</option>
              <option value="prioritized">Tool-prior override</option>
            </select>
          </label>
          <label>Explicit effects weight <input id="effect-lab-explicit" type="number" value="1.2" min="0" max="3" step="0.1" /></label>
          <label>Tool priors weight <input id="effect-lab-priors" type="number" value="0.8" min="0" max="3" step="0.1" /></label>
        </div>
        <div class="field-grid" style="margin-top:8px">
          <label>Heuristics weight <input id="effect-lab-heuristics" type="number" value="0.5" min="0" max="3" step="0.1" /></label>
          <div></div>
          <div></div>
        </div>
        <h4 style="margin: 10px 0 6px">Category weighting and precedence order</h4>
        <p class="muted">Drag priority via up/down. Higher-ranked categories receive stronger precedence multipliers in adjusted scoring.</p>
        <div id="effect-lab-weights" class="slider-grid"></div>
        <div class="grid two-col" style="margin-top:12px">
          <div>
            <h4 style="margin: 0 0 6px">Baseline vs adjusted summary</h4>
            <pre id="effect-lab-summary"></pre>
          </div>
          <div>
            <h4 style="margin: 0 0 6px">Per-axis comparison</h4>
            <table><thead><tr><th>Axis</th><th>Baseline</th><th>Adjusted</th><th>Δ</th></tr></thead><tbody id="effect-lab-table"></tbody></table>
          </div>
        </div>
      </section>

      <section class="card" style="margin-top: 16px">
        <h3>Explainability: Aggregate Risk Contributions</h3>
        <p class="muted">Shows each step's contribution along the dominant risk path per axis.</p>
        <table><thead><tr><th>Axis</th><th>Aggregate</th><th>Critical path terminal</th><th>Step contributions</th></tr></thead><tbody id="contrib-table"></tbody></table>
      </section>

      <section class="card" style="margin-top: 16px">
        <h3>Streaming Evaluation Timeline</h3>
        <p class="muted">Simulate evolving plans and visualize risk growth, threshold crossings, and rationale deltas from judge outputs.</p>
        <pre id="streaming"></pre>
      </section>

      <section class="card" style="margin-top: 16px">
        <h3>What-if Lab</h3>
        <p class="muted">Adjust descriptions, tools, and effect magnitudes. Updates flow into plan JSON and re-evaluate automatically.</p>
        <div class="controls" style="margin-bottom:10px"><button id="suggest-effects" class="secondary">Suggest effects</button></div>
        <div id="whatif-editors"></div>
      </section>

      <section class="card" style="margin-top: 16px">
        <h3>Multi-agent Session Builder</h3>
        <p class="muted">Compose per-agent plans, tune team/global budgets, and inspect laundering signals and aggregate budget pressure.</p>
        <div class="field-grid">
          <label>Global budget: cost_usd<input id="session-budget-cost" type="number" min="0" step="1" value="150" /></label>
          <label>Global budget: time_horizon_days<input id="session-budget-time" type="number" min="0" step="1" value="7" /></label>
          <label>Global budget: max_tool_calls<input id="session-budget-tools" type="number" min="0" step="1" value="6" /></label>
        </div>
        <div class="controls" style="margin-bottom:10px">
          <button id="add-agent" class="secondary">Add agent</button>
          <button id="sync-from-current-plan" class="secondary">Sync current plan as agent-1</button>
        </div>
        <div id="agent-editors"></div>
      </section>

      <section class="grid two-col" style="margin-top: 16px">
        <div class="card">
          <h3>Session payload preview</h3>
          <pre id="session-payload"></pre>
        </div>
        <div class="card">
          <h3>Session result</h3>
          <div id="session-decision"></div>
          <pre id="session-result"></pre>
        </div>
      </section>
      <section class="grid two-col" style="margin-top: 16px">
        <div class="card">
          <h3>Plugin Marketplace</h3>
          <p class="muted">Discover community plugins by domain focus, version, and signature status; install directly into your runtime environment.</p>
          <table>
            <thead>
              <tr>
                <th>Bundle</th>
                <th>Domain focus</th>
                <th>Version</th>
                <th>Signature</th>
                <th>Status</th>
              </tr>
            </thead>
            <tbody id="plugin-marketplace-table"></tbody>
          </table>
          <pre id="plugin-marketplace"></pre>
        </div>
        <div class="card">
          <h3>Plugin Manager</h3>
          <div class="controls" style="margin-bottom: 8px;">
            <input id="plugin-source" placeholder="/path/to/plugin-bundle.yaml" style="flex:1; min-width: 220px;" />
            <input id="plugin-target-dir" placeholder="/path/to/plugins-dir" style="flex:1; min-width: 220px;" />
          </div>
          <div class="controls" style="margin-bottom: 8px;">
            <button id="plugin-install">Install bundle</button>
            <button id="plugin-uninstall" class="secondary">Uninstall bundle</button>
          </div>
          <pre id="plugin-manager"></pre>
        </div>
      </section>

      <section class="card" style="margin-top: 16px">
        <h3>Plugin Authoring Wizard</h3>
        <p class="muted">Generate a signed plugin skeleton from domain, tools, effects mappings, and policy templates.</p>
        <div class="field-grid">
          <label>Domain<input id="plugin-wizard-domain" type="text" value="robotics" /></label>
          <label>Publisher<input id="plugin-wizard-publisher" type="text" value="community" /></label>
          <label>Name<input id="plugin-wizard-name" type="text" value="robotics-starter" /></label>
        </div>
        <div class="field-grid">
          <label>Version<input id="plugin-wizard-version" type="text" value="0.1.0" /></label>
          <label>Key ID<input id="plugin-wizard-key-id" type="text" value="community-main" /></label>
          <label>Signing Secret<input id="plugin-wizard-secret" type="text" value="" placeholder="required for signing" /></label>
        </div>
        <label>Tools (comma-separated)<input id="plugin-wizard-tools" type="text" value="move_arm,calibrate_sensor" /></label>
        <label>Tool definitions JSON (optional)
          <textarea id="plugin-wizard-tool-definitions" style="min-height:120px">[
  {"tool":"move_arm","category":"robotics_operations","risk_class":"high","domains":["robotics"],"priors":{"irreversibility":0.6,"uncertainty":0.2}}
]</textarea>
        </label>
        <label>Effects mappings JSON
          <textarea id="plugin-wizard-effects" style="min-height:120px">[
  {"trigger":"move_arm","axes":{"irreversibility":0.5,"stakeholder_radius":0.3}}
]</textarea>
        </label>
        <label>Policy rule templates (one per line)
          <textarea id="plugin-wizard-policy" style="min-height:90px">Require operator approval for physical actuation.
Require rollback plan before high-irreversibility actions.</textarea>
        </label>
        <div class="controls" style="margin-top:8px">
          <button id="plugin-wizard-generate">Generate signed skeleton</button>
        </div>
        <pre id="plugin-wizard-output"></pre>
        <pre id="plugin-wizard-lint-output"></pre>
        <h3>Policy Editing Workbench</h3>
        <p class="muted">View backend policy assets + signed plugin rules, tune thresholds, propose rule edits, and test safely before apply.</p>
        <div class="field-grid">
          <label>Backend
            <select id="policy-backend-select">
              <option value="python">python</option>
              <option value="opa">opa</option>
              <option value="cedar">cedar</option>
            </select>
          </label>
          <label>Editor token
            <input id="policy-editor-token" type="text" placeholder="X-ScopeBench-Policy-Token" />
          </label>
          <label>Summary
            <input id="policy-summary" type="text" placeholder="Why this policy change is needed" />
          </label>
        </div>
        <div class="controls" style="margin-bottom: 8px;">
          <button id="policy-refresh" class="secondary">Refresh policy state</button>
          <button id="policy-test" class="secondary">Test policy edits</button>
          <button id="policy-apply">Apply proposal</button>
        </div>
        <div class="grid two-col">
          <div>
            <h4>Threshold overrides (JSON)</h4>
            <textarea id="policy-threshold-overrides" style="min-height: 130px">{}</textarea>
            <h4>Proposed rules (JSON array)</h4>
            <textarea id="policy-rules-proposal" style="min-height: 160px">[]</textarea>
          </div>
          <div>
            <h4>Policy state</h4>
            <pre id="policy-workbench-state"></pre>
            <h4>Policy test/apply output</h4>
            <pre id="policy-workbench-output"></pre>
          </div>
        </div>
      </section>

      <section class="grid" style="margin-top: 16px">
      <section class="grid two-col" style="margin-top: 16px">
        <div class="card">
          <h3>Per-agent aggregates</h3>
          <table><thead><tr><th>Agent</th><th>Decision</th><th>Top axes</th><th>Budget utilization</th></tr></thead><tbody id="session-agent-table"></tbody></table>
        </div>
        <div class="card">
          <h3>Global aggregate & laundering detection</h3>
          <h4>Per-agent aggregate</h4>
          <table><thead><tr><th>Agent</th><th>Decision</th><th>Aggregate</th></tr></thead><tbody id="session-agent-table"></tbody></table>
          <h4 style="margin-top:12px">Global aggregate</h4>
          <table><thead><tr><th>Metric</th><th>Value</th></tr></thead><tbody id="session-global-table"></tbody></table>
          <h4 style="margin-top:12px">Laundering signals</h4>
          <table><thead><tr><th>Axis</th><th>Global</th><th>Max agent</th><th>Delta</th><th>Ask threshold</th></tr></thead><tbody id="session-laundering-table"></tbody></table>
          <div class="chart-block">
            <div class="chart-title">Risk profile (global vs max agent)</div>
            <div id="session-risk-chart"></div>
          </div>
        </div>
      </section>

      <section class="card" style="margin-top: 16px">
        <h3>Dataset Case Explorer</h3>
        <p class="muted">Browse benchmark cases by domain, expected decision, and instruction. Select a case to inspect full contract, plan, rationale, and step vectors.</p>
        <div class="case-explorer-controls">
          <input id="case-search" type="text" placeholder="Search by instruction, id, or rationale" />
          <select id="case-domain-filter"></select>
          <select id="case-decision-filter"></select>
        </div>
        <div class="controls" style="margin-bottom: 10px">
          <button id="refresh-cases" class="secondary">Refresh cases</button>
          <span id="case-summary" class="muted"></span>
        </div>
        <section class="grid two-col">
          <div>
            <div id="case-list" class="case-list"></div>
          </div>
          <div>
            <pre id="case-detail"></pre>
          </div>
        </section>
        <h3>Budget consumption ledger</h3>
        <p class="muted">Tracks consumed budget vs limits for each agent and globally, plus laundering pressure chips.</p>
        <div class="chart-block">
          <div class="chart-title">Budget consumption (agent vs global)</div>
          <div id="session-budget-chart"></div>
        </div>
        <div id="session-ledger" class="ledger-grid"></div>
      </section>

      <section class="card" style="margin-top: 16px">
        <h3>Dataset Contribution Draft</h3>
        <p class="muted">Wizard flow: draft a case, auto-fill vectors via <code>/dataset/suggest</code>, validate with <code>/dataset/validate</code>, then export a ready-to-submit JSONL contribution.</p>
        <div class="field-grid">
          <label>Case ID<input id="dataset-case-id" type="text" value="community_case_001" /></label>
          <label>Domain<input id="dataset-domain" type="text" value="engineering" /></label>
          <label>Expected decision
            <select id="dataset-expected-decision">
              <option>ALLOW</option>
              <option>ASK</option>
              <option>DENY</option>
            </select>
          </label>
        </div>
        <label>Instruction<input id="dataset-instruction" type="text" value="Fix flaky CI test" /></label>
        <label>Expected rationale<input id="dataset-expected-rationale" type="text" value="Scoped to local test stabilization with validation." /></label>
        <div class="dataset-wizard-steps" id="dataset-wizard-steps">
          <div class="dataset-wizard-step"><strong>1</strong><span>Build draft from contract + plan</span><span class="status-chip" id="dataset-step-build">pending</span></div>
          <div class="dataset-wizard-step"><strong>2</strong><span>Auto-fill vectors from <code>/dataset/suggest</code></span><span class="status-chip" id="dataset-step-suggest">pending</span></div>
          <div class="dataset-wizard-step"><strong>3</strong><span>Validate schema with <code>/dataset/validate</code></span><span class="status-chip" id="dataset-step-validate">pending</span></div>
          <div class="dataset-wizard-step"><strong>4</strong><span>Generate ready-to-submit JSONL contribution</span><span class="status-chip" id="dataset-step-generate">pending</span></div>
        </div>
        <div class="controls" style="margin: 10px 0">
          <button id="dataset-run-wizard">Run full wizard</button>
          <button id="dataset-build" class="secondary">Build draft from contract+plan</button>
          <button id="dataset-validate-panel" class="secondary">Validate draft</button>
          <button id="dataset-suggest-panel" class="secondary">Auto-suggest vectors</button>
          <button id="dataset-generate-file">Generate JSONL line</button>
          <button id="dataset-generate-pr" class="secondary">Generate PR text</button>
        </div>
        <textarea id="case-draft" style="min-height: 220px"></textarea>
        <h4 style="margin: 8px 0 6px">Contribution file preview</h4>
        <textarea id="dataset-contribution-file" style="min-height: 100px" readonly></textarea>
        <pre id="dataset-output"></pre>
      </section>

      <section class="grid two-col" style="margin-top: 16px">
        <div class="card"><h3>Catalog</h3><pre id="catalog"></pre></div>
        <div class="card"><h3>Telemetry Replay</h3><pre id="telemetry"></pre></div>
      </section>
      <section class="grid" style="margin-top: 16px">
        <div class="card"><h3>Cross-case Analytics Dashboard</h3><pre id="cases-analytics-dashboard"></pre></div>
        <div class="card">
          <h3>Calibration Dashboard</h3>
          <p class="muted">Interactive analytics for telemetry-driven calibration, thresholds, and simulated plan impact.</p>
          <div class="controls" style="margin-bottom:8px">
            <label>Domain <select id="calibration-domain"></select></label>
            <label>Sample plan preset
              <select id="calibration-plan-preset">
                <option value="team">team</option>
                <option value="enterprise">enterprise</option>
                <option value="regulated">regulated</option>
                <option value="personal">personal</option>
              </select>
            </label>
            <button id="calibration-apply-adjustments" class="secondary">Apply adjustments</button>
          </div>
          <div id="calibration-adjust-status" class="muted" style="margin-bottom:8px"></div>
          <div class="grid two-col" id="calibration-controls"></div>
          <div class="grid two-col" style="margin-top:10px">
            <div><h4>Per-axis score distributions</h4><div id="calibration-distributions"></div></div>
            <div><h4>False-alarm vs override rates</h4><div id="calibration-rates"></div></div>
          </div>
          <div class="grid two-col" style="margin-top:10px">
            <div><h4>Preset thresholds</h4><div id="calibration-thresholds"></div></div>
            <div><h4>Sample plan threshold pressure</h4><div id="calibration-plan-impact"></div></div>
          </div>
          <h4 style="margin-top:10px">Raw payload</h4>
          <pre id="calibration-raw"></pre>
        </div>
      </section>
    </main>

    <script>
      const defaultContract = { goal: "Fix flaky CI test", preset: "team" };
      const defaultPlan = {
        task: "Fix flaky CI test",
        steps: [
          { id: "1", description: "Inspect failing test", tool: "git_read" },
          { id: "2", description: "Patch timing", tool: "git_patch", depends_on: ["1"] },
          { id: "3", description: "Run pytest", tool: "pytest", depends_on: ["2"] }
        ]
      };

      const defaultSessionState = {
        agents: [
          { agent_id: "agent-a", budgets: { cost_usd: 70, time_horizon_days: 4, max_tool_calls: 4 }, plan: { task: "Fix parser bug", steps: [{ id: "1", description: "Read failing unit test and source", tool: "git_read" }, { id: "2", description: "Apply minimal parser patch", tool: "git_patch", depends_on: ["1"] }] } },
          { agent_id: "agent-b", budgets: { cost_usd: 45, time_horizon_days: 3, max_tool_calls: 3 }, plan: { task: "Validate parser patch", steps: [{ id: "1", description: "Review impact and identify tests", tool: "analysis" }, { id: "2", description: "Run targeted tests", tool: "pytest", depends_on: ["1"] }] } }
        ]
      };

      const el = (id) => document.getElementById(id);
      const contractEl = el("contract");
      const planEl = el("plan");
      const dagEl = el("dag");
      const resultEl = el("result");
      const decisionEl = el("decision");
      const axisTableEl = el("axis-table");
      const rationaleTableEl = el("rationale-table");
      const contribTableEl = el("contrib-table");
      const whatIfEditorsEl = el("whatif-editors");
      const catalogEl = el("catalog");
      const telemetryEl = el("telemetry");
      const calibrationRawEl = el("calibration-raw");
      const casesAnalyticsDashboardEl = el("cases-analytics-dashboard");
      const calibrationDomainEl = el("calibration-domain");
      const calibrationControlsEl = el("calibration-controls");
      const calibrationDistributionsEl = el("calibration-distributions");
      const calibrationRatesEl = el("calibration-rates");
      const calibrationThresholdsEl = el("calibration-thresholds");
      const calibrationPlanImpactEl = el("calibration-plan-impact");
      const calibrationPlanPresetEl = el("calibration-plan-preset");
      const calibrationApplyAdjustmentsEl = el("calibration-apply-adjustments");
      const calibrationAdjustStatusEl = el("calibration-adjust-status");
      const streamingEl = el("streaming");
      const pluginMarketplaceEl = el("plugin-marketplace");
      const pluginMarketplaceTableEl = el("plugin-marketplace-table");
      const pluginManagerEl = el("plugin-manager");
      const pluginSourceEl = el("plugin-source");
      const pluginTargetDirEl = el("plugin-target-dir");
      const pluginWizardDomainEl = el("plugin-wizard-domain");
      const pluginWizardPublisherEl = el("plugin-wizard-publisher");
      const pluginWizardNameEl = el("plugin-wizard-name");
      const pluginWizardVersionEl = el("plugin-wizard-version");
      const pluginWizardKeyIdEl = el("plugin-wizard-key-id");
      const pluginWizardSecretEl = el("plugin-wizard-secret");
      const pluginWizardToolsEl = el("plugin-wizard-tools");
      const pluginWizardEffectsEl = el("plugin-wizard-effects");
      const pluginWizardToolDefinitionsEl = el("plugin-wizard-tool-definitions");
      const pluginWizardPolicyEl = el("plugin-wizard-policy");
      const pluginWizardOutputEl = el("plugin-wizard-output");
      const pluginWizardLintOutputEl = el("plugin-wizard-lint-output");
      const templateSelectEl = el("template-select");
      const autoRunEl = el("auto-run");
      const wizardGoalEl = el("wizard-goal");
      const wizardDomainEl = el("wizard-domain");
      const wizardVariantEl = el("wizard-variant");
      const wizardPresetEl = el("wizard-preset");
      const wizardStepsEl = el("wizard-steps");
      const caseDraftEl = el("case-draft");
      const datasetOutputEl = el("dataset-output");
      const policyBackendSelectEl = el("policy-backend-select");
      const policyEditorTokenEl = el("policy-editor-token");
      const policySummaryEl = el("policy-summary");
      const policyThresholdOverridesEl = el("policy-threshold-overrides");
      const policyRulesProposalEl = el("policy-rules-proposal");
      const policyWorkbenchStateEl = el("policy-workbench-state");
      const policyWorkbenchOutputEl = el("policy-workbench-output");
      const effectLabModeEl = el("effect-lab-mode");
      const effectLabExplicitEl = el("effect-lab-explicit");
      const effectLabPriorsEl = el("effect-lab-priors");
      const effectLabHeuristicsEl = el("effect-lab-heuristics");
      const effectLabWeightsEl = el("effect-lab-weights");
      const effectLabSummaryEl = el("effect-lab-summary");
      const effectLabTableEl = el("effect-lab-table");
      const caseSearchEl = el("case-search");
      const caseDomainFilterEl = el("case-domain-filter");
      const caseDecisionFilterEl = el("case-decision-filter");
      const caseListEl = el("case-list");
      const caseDetailEl = el("case-detail");
      const caseSummaryEl = el("case-summary");
      const datasetCaseIdEl = el("dataset-case-id");
      const datasetDomainEl = el("dataset-domain");
      const datasetInstructionEl = el("dataset-instruction");
      const datasetExpectedDecisionEl = el("dataset-expected-decision");
      const datasetExpectedRationaleEl = el("dataset-expected-rationale");
      const datasetContributionFileEl = el("dataset-contribution-file");
      const datasetStepEls = {
        build: el("dataset-step-build"),
        suggest: el("dataset-step-suggest"),
        validate: el("dataset-step-validate"),
        generate: el("dataset-step-generate"),
      };
      const suggestEffectsEl = el("suggest-effects");
      const EFFECT_AXES = [
        ["resources", "resource_intensity"],
        ["legal", "legal_exposure"],
        ["stakeholders", "stakeholder_radius"],
        ["irreversible_actions", "irreversibility"],
        ["geo_scope", "spatial"],
        ["time_horizon", "temporal"]
      ];
      const agentEditorsEl = el("agent-editors");
      const sessionPayloadEl = el("session-payload");
      const sessionDecisionEl = el("session-decision");
      const sessionResultEl = el("session-result");
      const sessionAgentTableEl = el("session-agent-table");
      const sessionGlobalTableEl = el("session-global-table");
      const sessionLaunderingTableEl = el("session-laundering-table");
      const sessionLedgerEl = el("session-ledger");
      const sessionBudgetChartEl = el("session-budget-chart");
      const sessionRiskChartEl = el("session-risk-chart");
      const MAGNITUDE = ["none", "low", "medium", "high", "extreme"];
      let knownTools = [];
      let autoTimer = null;
      let wizardTemplates = [];
      let wizardDraft = null;
      let sessionState = JSON.parse(JSON.stringify(defaultSessionState));
      let calibrationDashboardState = null;
      let calibrationSelection = { domain: null, axisScaleDelta: {}, axisThresholdFactorDelta: {}, abstainDelta: 0.0 };
      let latestEvaluation = null;
      let allCases = [];
      let selectedCaseId = null;
      let effectLabAxisOrder = EFFECT_AXES.map(([, axis]) => axis);

      contractEl.value = JSON.stringify(defaultContract, null, 2);
      planEl.value = JSON.stringify(defaultPlan, null, 2);
      caseDraftEl.value = JSON.stringify({
        case_schema_version: "1.0",
        id: "community_case_001",
        domain: "engineering",
        instruction: "Fix flaky CI test",
        contract: defaultContract,
        plan: defaultPlan,
        expected_decision: "ALLOW",
        expected_rationale: "Scoped to local test stabilization with validation.",
        expected_step_vectors: [
          {
            step_id: "1", spatial: 0.1, temporal: 0.1, depth: 0.1, irreversibility: 0.1,
            resource_intensity: 0.1, legal_exposure: 0.1, dependency_creation: 0.1,
            stakeholder_radius: 0.1, power_concentration: 0.1, uncertainty: 0.2
          },
          {
            step_id: "2", spatial: 0.2, temporal: 0.2, depth: 0.3, irreversibility: 0.2,
            resource_intensity: 0.2, legal_exposure: 0.1, dependency_creation: 0.2,
            stakeholder_radius: 0.2, power_concentration: 0.2, uncertainty: 0.3
          },
          {
            step_id: "3", spatial: 0.1, temporal: 0.1, depth: 0.2, irreversibility: 0.1,
            resource_intensity: 0.1, legal_exposure: 0.1, dependency_creation: 0.1,
            stakeholder_radius: 0.1, power_concentration: 0.1, uncertainty: 0.2
          }
        ]
      }, null, 2);
      syncDatasetFieldsFromDraft(JSON.parse(caseDraftEl.value));
      datasetContributionFileEl.value = "";

      function setDatasetWizardStep(step, status, text) {
        const node = datasetStepEls[step];
        if (!node) return;
        node.classList.remove("done", "running", "error");
        if (status === "done") node.classList.add("done");
        if (status === "running") node.classList.add("running");
        if (status === "error") node.classList.add("error");
        node.textContent = text || status;
      }

      function resetDatasetWizardSteps() {
        setDatasetWizardStep("build", "pending", "pending");
        setDatasetWizardStep("suggest", "pending", "pending");
        setDatasetWizardStep("validate", "pending", "pending");
        setDatasetWizardStep("generate", "pending", "pending");
      }

      resetDatasetWizardSteps();

      function decisionBadge(decision) { const n = String(decision || "").toLowerCase(); const cls = n === "allow" ? "allow" : n === "ask" ? "ask" : "deny"; return `<span class="badge ${cls}">${decision || "UNKNOWN"}</span>`; }
      function toMagnitude(v) { return MAGNITUDE[Math.max(0, Math.min(MAGNITUDE.length - 1, Math.round(Number(v || 0) * 4)))]; }
      function renderDag(plan) {
        const nodes = (plan.steps || []).map((s) => `${s.id} [${s.tool || "none"}]`).join("\n");
        const edges = (plan.steps || []).flatMap((s) => (s.depends_on || []).map((dep) => `${dep} -> ${s.id}`)).join("\n");
        dagEl.textContent = `nodes:\n${nodes || "(none)"}\n\nedges:\n${edges || "(none)"}`;
      }

      function renderAggregate(aggregate = {}) { axisTableEl.innerHTML = ""; Object.entries(aggregate).sort((a, b) => b[1] - a[1]).forEach(([axis, score]) => { const tr = document.createElement("tr"); tr.innerHTML = `<td>${axis}</td><td>${Number(score).toFixed(3)}</td>`; axisTableEl.appendChild(tr); }); }

      function moveEffectLabAxis(axisKey, direction) {
        const index = effectLabAxisOrder.indexOf(axisKey);
        if (index < 0) return;
        const nextIndex = direction === "up" ? index - 1 : index + 1;
        if (nextIndex < 0 || nextIndex >= effectLabAxisOrder.length) return;
        const reordered = [...effectLabAxisOrder];
        [reordered[index], reordered[nextIndex]] = [reordered[nextIndex], reordered[index]];
        effectLabAxisOrder = reordered;
        renderEffectLabWeightControls();
        renderEffectLabComparison();
      }

      function renderEffectLabWeightControls() {
        const axisWeightState = Object.fromEntries(
          Array.from(effectLabWeightsEl.querySelectorAll("input[data-axis-weight]")).map((node) => [node.dataset.axisWeight, Number(node.value || 1)])
        );
        effectLabWeightsEl.innerHTML = effectLabAxisOrder.map((axisKey, rankIndex) => {
          const sliderValue = Number(axisWeightState[axisKey] || 1);
          return `
            <div class="slider-row">
              <div class="effect-row-header">
                <span class="effect-row-rank" title="precedence rank">${rankIndex + 1}</span>
                <div class="inline-label"><strong>${axisKey}</strong><span data-axis-value="${axisKey}">${sliderValue.toFixed(2)}x</span></div>
                <div class="axis-order-controls">
                  <button class="secondary" type="button" data-axis-move="up" data-axis-key="${axisKey}" ${rankIndex === 0 ? "disabled" : ""}>↑</button>
                  <button class="secondary" type="button" data-axis-move="down" data-axis-key="${axisKey}" ${rankIndex === effectLabAxisOrder.length - 1 ? "disabled" : ""}>↓</button>
                </div>
              </div>
              <input type="range" min="0" max="2.5" step="0.1" value="${sliderValue}" data-axis-weight="${axisKey}" />
            </div>
          `;
        }).join("");
        effectLabWeightsEl.querySelectorAll("input[data-axis-weight]").forEach((node) => {
          node.addEventListener("input", (ev) => {
            const axis = ev.target.dataset.axisWeight;
            const value = Number(ev.target.value || 1);
            const label = effectLabWeightsEl.querySelector(`[data-axis-value="${axis}"]`);
            if (label) label.textContent = `${value.toFixed(2)}x`;
            renderEffectLabComparison();
          });
        });
        effectLabWeightsEl.querySelectorAll("button[data-axis-move]").forEach((node) => {
          node.addEventListener("click", (ev) => {
            moveEffectLabAxis(ev.target.dataset.axisKey, ev.target.dataset.axisMove);
          });
        });
      }

      function getEffectLabState() {
        const axisWeights = Object.fromEntries(Array.from(effectLabWeightsEl.querySelectorAll("input[data-axis-weight]")).map((node) => [node.dataset.axisWeight, Number(node.value || 1)]));
        const axisPrecedence = Object.fromEntries(effectLabAxisOrder.map((axis, index) => {
          const multiplier = 1 + ((effectLabAxisOrder.length - 1 - index) * 0.05);
          return [axis, Number(multiplier.toFixed(2))];
        }));
        return {
          mode: effectLabModeEl.value,
          explicitWeight: Number(effectLabExplicitEl.value || 0),
          priorsWeight: Number(effectLabPriorsEl.value || 0),
          heuristicsWeight: Number(effectLabHeuristicsEl.value || 0),
          axisWeights,
          axisOrder: [...effectLabAxisOrder],
          axisPrecedence
        };
      }

      function inferAxisSignalScores(plan, baseline = {}) {
        const steps = plan.steps || [];
        const scoreFromMagnitude = (value) => {
          const idx = MAGNITUDE.indexOf(String(value || "none").toLowerCase());
          return Math.max(0, idx) / (MAGNITUDE.length - 1);
        };
        const heuristicsByAxis = {};
        const priorsByAxis = {};
        const explicitByAxis = {};
        Object.values(EFFECT_AXES).forEach(([, axis]) => {
          heuristicsByAxis[axis] = Number(baseline[axis] || 0);
          priorsByAxis[axis] = Number(baseline[axis] || 0) * 0.7;
          explicitByAxis[axis] = 0;
        });
        steps.forEach((step) => {
          EFFECT_AXES.forEach(([effectKey, axis]) => {
            const explicit = scoreFromMagnitude(step.effects?.[effectKey]);
            explicitByAxis[axis] = Math.max(explicitByAxis[axis], explicit);
          });
          const text = `${step.description || ""} ${step.tool || ""}`.toLowerCase();
          if (text.includes("prod") || text.includes("deploy") || text.includes("rollout")) heuristicsByAxis.stakeholder_radius = Math.max(heuristicsByAxis.stakeholder_radius || 0, 0.6);
          if (text.includes("legal") || text.includes("compliance") || text.includes("regulat")) heuristicsByAxis.legal_exposure = Math.max(heuristicsByAxis.legal_exposure || 0, 0.6);
          if (text.includes("data") || text.includes("migration") || text.includes("delete")) heuristicsByAxis.irreversibility = Math.max(heuristicsByAxis.irreversibility || 0, 0.5);
          if (text.includes("audit") || text.includes("report")) priorsByAxis.resource_intensity = Math.max(priorsByAxis.resource_intensity || 0, 0.5);
        });
        return { explicitByAxis, priorsByAxis, heuristicsByAxis };
      }

      function applyEffectLabWeighting(baseline = {}, plan = {}) {
        const state = getEffectLabState();
        const signals = inferAxisSignalScores(plan, baseline);
        const adjusted = {};
        Object.entries(baseline || {}).forEach(([axis, base]) => {
          const explicit = Number(signals.explicitByAxis[axis] || 0);
          const priors = Number(signals.priorsByAxis[axis] || 0);
          const heuristics = Number(signals.heuristicsByAxis[axis] || 0);
          let signalBlend = Number(base || 0);
          if (state.mode === "strict") {
            signalBlend = explicit > 0 ? explicit * state.explicitWeight : priors > 0 ? priors * state.priorsWeight : heuristics * state.heuristicsWeight;
          } else if (state.mode === "prioritized") {
            signalBlend = priors * state.priorsWeight + explicit * (state.explicitWeight * 0.35) + heuristics * (state.heuristicsWeight * 0.2);
          } else {
            const denom = Math.max(0.001, state.explicitWeight + state.priorsWeight + state.heuristicsWeight);
            signalBlend = ((explicit * state.explicitWeight) + (priors * state.priorsWeight) + (heuristics * state.heuristicsWeight)) / denom;
          }
          const precedenceBoost = Number(state.axisPrecedence?.[axis] || 1);
          adjusted[axis] = Math.max(0, Math.min(1.5, signalBlend * Number(state.axisWeights[axis] || 1) * precedenceBoost));
        });
        return { adjusted, signals, state };
      }

      function effectLabDecision(aggregate = {}) {
        const top = Math.max(0, ...Object.values(aggregate).map((v) => Number(v || 0)));
        if (top >= 0.85) return "DENY";
        if (top >= 0.55) return "ASK";
        return "ALLOW";
      }

      function renderEffectLabComparison() {
        if (!latestEvaluation?.aggregate) {
          effectLabSummaryEl.textContent = "Run /evaluate to populate baseline aggregate scores.";
          effectLabTableEl.innerHTML = "";
          return;
        }
        const baseline = latestEvaluation.aggregate || {};
        const plan = latestEvaluation.plan || {};
        const { adjusted, state } = applyEffectLabWeighting(baseline, plan);
        const baseDecision = effectLabDecision(baseline);
        const adjustedDecision = effectLabDecision(adjusted);
        const maxAdjustedAxis = Object.entries(adjusted).sort((a, b) => Number(b[1] || 0) - Number(a[1] || 0))[0]?.[0] || "n/a";
        effectLabSummaryEl.textContent = JSON.stringify({
          precedence_mode: state.mode,
          axis_order: state.axisOrder,
          axis_precedence_multipliers: state.axisPrecedence,
          baseline_decision: baseDecision,
          adjusted_decision: adjustedDecision,
          dominant_adjusted_axis: maxAdjustedAxis,
          note: "Explicit effects can dominate in strict mode, or be blended/overridden for domain-specific sensitivity analysis."
        }, null, 2);
        effectLabTableEl.innerHTML = "";
        Object.keys(baseline).sort((a, b) => Number(adjusted[b] || 0) - Number(adjusted[a] || 0)).forEach((axis) => {
          const b = Number(baseline[axis] || 0);
          const a = Number(adjusted[axis] || 0);
          const tr = document.createElement("tr");
          tr.innerHTML = `<td>${axis}</td><td>${b.toFixed(3)}</td><td>${a.toFixed(3)}</td><td>${(a - b).toFixed(3)}</td>`;
          effectLabTableEl.appendChild(tr);
        });
      }
      function renderStepRationales(steps = []) {
        rationaleTableEl.innerHTML = "";
        const rows = [];
        steps.forEach((step) => Object.entries(step.axes || {}).forEach(([axis, detail]) => rows.push({ step: step.step_id || "unknown", axis, ...detail })));
        rows.sort((a, b) => b.value - a.value).forEach((row) => { const tr = document.createElement("tr"); tr.innerHTML = `<td>${row.step}</td><td>${row.axis}</td><td>${Number(row.value).toFixed(3)}</td><td>${Number(row.confidence || 0).toFixed(2)}</td><td>${row.rationale || "n/a"}</td>`; rationaleTableEl.appendChild(tr); });
      }

      function topoOrder(plan) {
        const remaining = {}; (plan.steps || []).forEach((s) => { remaining[s.id] = [...(s.depends_on || [])]; });
        const ready = (plan.steps || []).filter((s) => !(s.depends_on || []).length).map((s) => s.id); const order = [];
        while (ready.length) { const node = ready.pop(); order.push(node); Object.entries(remaining).forEach(([stepId, deps]) => { const idx = deps.indexOf(node); if (idx >= 0) { deps.splice(idx, 1); if (!deps.length && !order.includes(stepId) && !ready.includes(stepId)) ready.push(stepId); } }); }
        return order;
      }

      function computeContributions(plan, steps, aggregate = {}) {
        const axes = Object.keys(aggregate || {}); const vectors = {};
        (steps || []).forEach((step) => { vectors[step.step_id] = Object.fromEntries(Object.entries(step.axes || {}).map(([axis, detail]) => [axis, Number(detail.value || 0)])); });
        const predecessors = Object.fromEntries((plan.steps || []).map((s) => [s.id, s.depends_on || []]));
        const order = topoOrder(plan); const pathScope = {}; const parentByAxis = {}; const deltaByAxis = {};
        order.forEach((stepId) => { pathScope[stepId] = {}; parentByAxis[stepId] = {}; deltaByAxis[stepId] = {}; axes.forEach((axis) => { let baseline = 0; let winnerPred = null; (predecessors[stepId] || []).forEach((pred) => { const predValue = pathScope[pred]?.[axis] ?? 0; if (predValue >= baseline) { baseline = predValue; winnerPred = pred; } }); const stepAxis = vectors[stepId]?.[axis] ?? 0; const updated = Math.max(baseline, stepAxis); pathScope[stepId][axis] = updated; parentByAxis[stepId][axis] = winnerPred; deltaByAxis[stepId][axis] = Math.max(0, updated - baseline); }); });
        return axes.map((axis) => { const agg = Number(aggregate[axis] || 0); let terminal = null; order.forEach((stepId) => { if ((pathScope[stepId]?.[axis] ?? 0) >= (pathScope[terminal]?.[axis] ?? -1)) terminal = stepId; }); const contributions = []; let cursor = terminal; while (cursor) { const delta = Number(deltaByAxis[cursor]?.[axis] || 0); if (delta > 0 || cursor === terminal) contributions.push({ stepId: cursor, delta }); cursor = parentByAxis[cursor]?.[axis] || null; } contributions.reverse(); const text = contributions.map((c) => `${c.stepId}: ${(agg > 0 ? (100 * c.delta) / agg : 0).toFixed(1)}% (${c.delta.toFixed(3)})`).join(" → "); return { axis, aggregate: agg, terminal, text: text || "(none)" }; });
      }
      function renderContributions(plan, steps, aggregate) { contribTableEl.innerHTML = ""; computeContributions(plan, steps, aggregate).sort((a, b) => b.aggregate - a.aggregate).forEach((entry) => { const tr = document.createElement("tr"); tr.innerHTML = `<td>${entry.axis}</td><td>${entry.aggregate.toFixed(3)}</td><td>${entry.terminal || "n/a"}</td><td>${entry.text}</td>`; contribTableEl.appendChild(tr); }); }

      function scheduleAutoEvaluate() { if (!autoRunEl.checked) return; if (autoTimer) clearTimeout(autoTimer); autoTimer = setTimeout(() => runEvaluation().catch((err) => { resultEl.textContent = `Error: ${err.message}`; }), 300); }

      function updatePlanField(stepIndex, field, value) { const plan = JSON.parse(planEl.value); if (!plan.steps?.[stepIndex]) return; plan.steps[stepIndex][field] = value; planEl.value = JSON.stringify(plan, null, 2); scheduleAutoEvaluate(); }
      function updateEffectMagnitude(stepIndex, effectKey, sliderValue) {
        const plan = JSON.parse(planEl.value); const step = plan.steps?.[stepIndex]; if (!step) return;
        step.effects = step.effects || {}; step.effects[effectKey] = toMagnitude(sliderValue); planEl.value = JSON.stringify(plan, null, 2); scheduleAutoEvaluate();
      }

      function applySuggestedEffects(plan, suggestions = []) {
        const nextPlan = JSON.parse(JSON.stringify(plan || { task: "", steps: [] }));
        const stepById = Object.fromEntries((nextPlan.steps || []).map((step) => [String(step.id), step]));
        (suggestions || []).forEach((item) => {
          const stepId = String(item?.step_id || "");
          if (!stepId || !stepById[stepId]) return;
          stepById[stepId].effects = item.effects || {};
        });
        return nextPlan;
      }

      async function suggestEffectsForPlan() {
        const plan = JSON.parse(planEl.value);
        const res = await fetch("/suggest_effects", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({ plan })
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.detail || JSON.stringify(data));
        const updatedPlan = applySuggestedEffects(data.plan || plan, data.suggestions || []);
        planEl.value = JSON.stringify(updatedPlan, null, 2);
        renderDag(updatedPlan);
        renderWhatIfEditors(updatedPlan);
        scheduleAutoEvaluate();
      }

      function renderWhatIfEditors(plan) {
        whatIfEditorsEl.innerHTML = "";
        (plan.steps || []).forEach((step, stepIndex) => {
          const container = document.createElement("div"); container.className = "step-editor";
          const options = knownTools.map((tool) => `<option value="${tool}" ${step.tool === tool ? "selected" : ""}>${tool}</option>`).join("");
          const sliders = EFFECT_AXES.map(([effectKey, axisKey]) => { const raw = step.effects?.[effectKey] || "none"; const value = Math.max(0, MAGNITUDE.indexOf(raw)) / (MAGNITUDE.length - 1); return `<div class="slider-row"><div class="inline-label"><strong>${axisKey}</strong><span>${raw}</span></div><input type="range" min="0" max="1" step="0.25" value="${value}" data-step="${stepIndex}" data-effect="${effectKey}" /></div>`; }).join("");
          container.innerHTML = `<h4>${step.id}</h4><label>Description</label><textarea data-field="description" data-step="${stepIndex}" style="min-height:72px">${step.description || ""}</textarea><label>Tool</label><select data-field="tool" data-step="${stepIndex}">${options}</select><div class="slider-grid" style="margin-top:10px">${sliders}</div>`;
          whatIfEditorsEl.appendChild(container);
        });
        whatIfEditorsEl.querySelectorAll("textarea[data-field], select[data-field]").forEach((node) => node.addEventListener("input", (ev) => updatePlanField(Number(ev.target.dataset.step), ev.target.dataset.field, ev.target.value)));
        whatIfEditorsEl.querySelectorAll("input[type='range']").forEach((node) => node.addEventListener("input", (ev) => { const value = Number(ev.target.value); ev.target.previousElementSibling.querySelector("span").textContent = toMagnitude(value); updateEffectMagnitude(Number(ev.target.dataset.step), ev.target.dataset.effect, value); }));
      }

      function parsePlanJson(text) {
        try {
          const parsed = JSON.parse(text || "{}");
          return parsed && typeof parsed === "object" ? parsed : { task: "", steps: [] };
        } catch (_err) {
          return { task: "", steps: [] };
        }
      }

      function sessionPayloadFromState() {
        const baseContract = JSON.parse(contractEl.value);
        const globalBudgets = {
          cost_usd: Number(el("session-budget-cost").value || 0),
          time_horizon_days: Number(el("session-budget-time").value || 0),
          max_tool_calls: Number(el("session-budget-tools").value || 0)
        };
        const global_contract = { ...baseContract, preset: baseContract.preset || "team", budgets: globalBudgets };
        return {
          session: {
            global_contract,
            agents: sessionState.agents.map((agent) => ({
              agent_id: agent.agent_id,
              contract: {
                ...global_contract,
                budgets: {
                  cost_usd: Number(agent.budgets?.cost_usd || 0),
                  time_horizon_days: Number(agent.budgets?.time_horizon_days || 0),
                  max_tool_calls: Number(agent.budgets?.max_tool_calls || 0)
                }
              }
            })),
            plans: sessionState.agents.map((agent) => ({ agent_id: agent.agent_id, plan: agent.plan }))
          },
          include_steps: false,
          include_telemetry: true
        };
      }

      function renderSessionBuilder() {
        agentEditorsEl.innerHTML = "";
        sessionState.agents.forEach((agent, idx) => {
          const node = document.createElement("div");
          node.className = "agent-editor";
          node.innerHTML = `<div class="agent-header"><input type="text" value="${agent.agent_id}" data-agent-id="${idx}" /><button class="secondary" data-remove-agent="${idx}">remove</button></div><div class="field-grid"><label>Budget: cost_usd<input data-agent-budget="cost_usd" data-agent-index="${idx}" type="number" min="0" step="1" value="${Number(agent.budgets?.cost_usd || 0)}" /></label><label>Budget: time_horizon_days<input data-agent-budget="time_horizon_days" data-agent-index="${idx}" type="number" min="0" step="1" value="${Number(agent.budgets?.time_horizon_days || 0)}" /></label><label>Budget: max_tool_calls<input data-agent-budget="max_tool_calls" data-agent-index="${idx}" type="number" min="0" step="1" value="${Number(agent.budgets?.max_tool_calls || 0)}" /></label></div><label>Agent plan (JSON)</label><textarea data-agent-plan="${idx}" style="min-height:130px">${JSON.stringify(agent.plan, null, 2)}</textarea>`;
          agentEditorsEl.appendChild(node);
        });
        sessionPayloadEl.textContent = JSON.stringify(sessionPayloadFromState(), null, 2);

        agentEditorsEl.querySelectorAll("input[data-agent-id]").forEach((node) => node.addEventListener("input", (ev) => {
          sessionState.agents[Number(ev.target.dataset.agentId)].agent_id = ev.target.value.trim() || `agent-${Number(ev.target.dataset.agentId) + 1}`;
          sessionPayloadEl.textContent = JSON.stringify(sessionPayloadFromState(), null, 2);
        }));
        agentEditorsEl.querySelectorAll("input[data-agent-budget]").forEach((node) => node.addEventListener("input", (ev) => {
          const idx = Number(ev.target.dataset.agentIndex);
          const budgetKey = ev.target.dataset.agentBudget;
          sessionState.agents[idx].budgets = sessionState.agents[idx].budgets || {};
          sessionState.agents[idx].budgets[budgetKey] = Number(ev.target.value || 0);
          sessionPayloadEl.textContent = JSON.stringify(sessionPayloadFromState(), null, 2);
        }));
        agentEditorsEl.querySelectorAll("textarea[data-agent-plan]").forEach((node) => node.addEventListener("input", (ev) => {
          const idx = Number(ev.target.dataset.agentPlan);
          try { sessionState.agents[idx].plan = JSON.parse(ev.target.value); }
          catch (_err) { sessionPayloadEl.textContent = "Session payload invalid: fix plan JSON to continue."; return; }
          sessionPayloadEl.textContent = JSON.stringify(sessionPayloadFromState(), null, 2);
        }));
        agentEditorsEl.querySelectorAll("button[data-remove-agent]").forEach((node) => node.addEventListener("click", (ev) => {
          const idx = Number(ev.target.dataset.removeAgent);
          sessionState.agents.splice(idx, 1);
          renderSessionBuilder();
        }));
      }

      function topAxesText(aggregate = {}) { return Object.entries(aggregate).sort((a, b) => b[1] - a[1]).slice(0, 3).map(([axis, value]) => `${axis}:${Number(value).toFixed(2)}`).join(", "); }
      function budgetUtilizationText(util = {}) { return Object.entries(util).map(([k, v]) => `${k}:${(100 * Number(v || 0)).toFixed(0)}%`).join(", ") || "n/a"; }

      function utilizationMeter(label, used, limit) {
        const safeLimit = Number(limit || 0);
        const safeUsed = Number(used || 0);
        const ratio = safeLimit > 0 ? safeUsed / safeLimit : 0;
        const percent = (100 * ratio).toFixed(0);
        return `<div><div class="inline-label"><span>${label}</span><strong>${safeUsed.toFixed(1)} / ${safeLimit.toFixed(1)}</strong></div><div class="meter"><span style="width:${Math.min(100, Math.max(0, ratio * 100))}%"></span></div><div class="muted">${percent}% consumed</div></div>`;
      }

      function renderBudgetBars(container, entries = []) {
        if (!container) return;
        container.innerHTML = "";
        if (!entries.length) {
          container.innerHTML = '<div class="muted">Run /evaluate_session to see budget consumption trends.</div>';
          return;
        }
        entries.forEach((entry) => {
          const row = document.createElement("div");
          row.className = "bar-row";
          const bounded = Math.max(0, Math.min(100, Number(entry.percent || 0)));
          row.innerHTML = `<div>${entry.label}</div><div class="bar-track"><div class="bar-fill budget" style="width:${bounded}%"></div></div><div>${bounded.toFixed(0)}%</div>`;
          container.appendChild(row);
        });
      }

      function renderRiskBars(container, entries = []) {
        if (!container) return;
        container.innerHTML = "";
        if (!entries.length) {
          container.innerHTML = '<div class="muted">No risk data available yet.</div>';
          return;
        }
        const max = Math.max(...entries.map((entry) => Number(entry.value || 0)), 0.001);
        entries.forEach((entry) => {
          const row = document.createElement("div");
          row.className = "bar-row";
          const percent = (100 * Number(entry.value || 0)) / max;
          row.innerHTML = `<div>${entry.label}</div><div class="bar-track"><div class="bar-fill risk" style="width:${percent.toFixed(1)}%"></div></div><div>${Number(entry.value || 0).toFixed(2)}</div>`;
          container.appendChild(row);
        });
      }

      function renderSessionDashboard(payload = {}) {
        sessionAgentTableEl.innerHTML = "";
        sessionGlobalTableEl.innerHTML = "";
        sessionLaunderingTableEl.innerHTML = "";
        sessionLedgerEl.innerHTML = "";

        Object.entries(payload.dashboard?.per_agent || {}).forEach(([agentId, entry]) => {
          const tr = document.createElement("tr");
          tr.innerHTML = `<td>${agentId}</td><td>${decisionBadge(entry.decision)}</td><td>${topAxesText(entry.aggregate)}</td><td>${budgetUtilizationText(entry.budget_utilization)}</td>`;
          sessionAgentTableEl.appendChild(tr);

          const source = sessionState.agents.find((agent) => agent.agent_id === agentId) || {};
          const consumption = entry.budget_consumption || {};
          const budgets = source.budgets || {};
          const card = document.createElement("div");
          card.className = "ledger-card";
          card.innerHTML = `<h4 style="margin:0 0 6px">${agentId}</h4>${utilizationMeter("cost_usd", consumption.cost_usd, budgets.cost_usd)}${utilizationMeter("time_horizon_days", consumption.time_horizon_days, budgets.time_horizon_days)}${utilizationMeter("max_tool_calls", consumption.max_tool_calls, budgets.max_tool_calls)}`;
          sessionLedgerEl.appendChild(card);
        });

        const global = payload.dashboard?.global || {};
        [["Decision", global.decision || payload.decision || "n/a"], ["Top axes", topAxesText(global.aggregate || {})], ["Budget utilization", budgetUtilizationText(global.budget_utilization || {})], ["Negotiation triggered", payload.negotiation?.triggered ? "yes" : "no"]].forEach(([k, v]) => {
          const tr = document.createElement("tr");
          tr.innerHTML = `<td>${k}</td><td>${v}</td>`;
          sessionGlobalTableEl.appendChild(tr);
        });

        (payload.laundering_signals || []).forEach((signal) => {
          const tr = document.createElement("tr");
          tr.innerHTML = `<td>${signal.axis}</td><td>${Number(signal.global_value).toFixed(3)}</td><td>${Number(signal.max_agent_value).toFixed(3)}</td><td>${Number(signal.delta).toFixed(3)}</td><td>${Number(signal.ask_threshold).toFixed(3)}</td>`;
          sessionLaunderingTableEl.appendChild(tr);
        });
        if (!(payload.laundering_signals || []).length) {
          const tr = document.createElement("tr");
          tr.innerHTML = "<td colspan='5'>No cross-agent laundering signals detected.</td>";
          sessionLaunderingTableEl.appendChild(tr);
        }

        const budgetChartRows = [];
        Object.entries(payload.dashboard?.per_agent || {}).forEach(([agentId, entry]) => {
          const util = entry.budget_utilization || {};
          ["cost_usd", "time_horizon_days", "max_tool_calls"].forEach((metric) => {
            budgetChartRows.push({ label: `${agentId} ${metric}`, percent: 100 * Number(util[metric] || 0) });
          });
        });
        const globalUtil = global.budget_utilization || {};
        ["cost_usd", "time_horizon_days", "max_tool_calls"].forEach((metric) => {
          budgetChartRows.push({ label: `global ${metric}`, percent: 100 * Number(globalUtil[metric] || 0) });
        });
        renderBudgetBars(sessionBudgetChartEl, budgetChartRows);

        const riskRows = [];
        const globalAggregate = global.aggregate || {};
        Object.entries(globalAggregate).sort((a, b) => Number(b[1]) - Number(a[1])).slice(0, 6).forEach(([axis, value]) => {
          const maxAgent = Math.max(...Object.values(payload.dashboard?.per_agent || {}).map((entry) => Number(entry.aggregate?.[axis] || 0)), 0);
          riskRows.push({ label: `${axis} global`, value: Number(value || 0) });
          riskRows.push({ label: `${axis} max-agent`, value: maxAgent });
        });
        renderRiskBars(sessionRiskChartEl, riskRows);

        const globalCard = document.createElement("div");
        globalCard.className = "ledger-card";
        const globalConsumption = global.budget_consumption || {};
        const globalBudget = {
          cost_usd: Number(el("session-budget-cost").value || 0),
          time_horizon_days: Number(el("session-budget-time").value || 0),
          max_tool_calls: Number(el("session-budget-tools").value || 0)
        };
        const launderingChips = (payload.laundering_signals || []).map((signal) => `<span class="signal-chip">${signal.axis} Δ${Number(signal.delta).toFixed(2)}</span>`).join("") || '<span class="muted">No laundering signals.</span>';
        globalCard.innerHTML = `<h4 style="margin:0 0 6px">Global</h4>${utilizationMeter("cost_usd", globalConsumption.cost_usd, globalBudget.cost_usd)}${utilizationMeter("time_horizon_days", globalConsumption.time_horizon_days, globalBudget.time_horizon_days)}${utilizationMeter("max_tool_calls", globalConsumption.max_tool_calls, globalBudget.max_tool_calls)}<div style="margin-top:8px"><strong>Laundering pressure</strong><div style="margin-top:4px">${launderingChips}</div></div>`;
        sessionLedgerEl.appendChild(globalCard);
      }


      function renderWizardVariantOptions() {
        const picked = wizardTemplates.find((item) => item.domain === wizardDomainEl.value);
        const variants = Object.keys(picked?.variants || {}).sort();
        wizardVariantEl.innerHTML = variants.map((v) => `<option value="${v}">${v}</option>`).join("");
      }

      function renderWizardSteps(plan) {
        wizardStepsEl.innerHTML = "";
        (plan.steps || []).forEach((step, idx) => {
          const row = document.createElement("div");
          row.className = "wizard-step";
          row.innerHTML = `
            <strong>${step.id || `step-${idx + 1}`}</strong>
            <input data-step="${idx}" data-field="description" value="${(step.description || "").replace(/"/g, "&quot;")}" />
            <input data-step="${idx}" data-field="tool" value="${(step.tool || "analysis").replace(/"/g, "&quot;")}" />
          `;
          wizardStepsEl.appendChild(row);
        });
        wizardStepsEl.querySelectorAll("input[data-step]").forEach((node) => {
          node.addEventListener("input", (ev) => {
            if (!wizardDraft) return;
            const stepIndex = Number(ev.target.dataset.step);
            const field = ev.target.dataset.field;
            wizardDraft.plan.steps[stepIndex][field] = ev.target.value;
          });
        });
      }

      function generateWizardDraft() {
        const domain = wizardDomainEl.value;
        const variant = wizardVariantEl.value;
        const pickedDomain = wizardTemplates.find((item) => item.domain === domain);
        const pickedVariant = pickedDomain?.variants?.[variant]?.content;
        if (!pickedVariant?.contract || !pickedVariant?.plan) return;

        const contract = JSON.parse(JSON.stringify(pickedVariant.contract));
        const plan = JSON.parse(JSON.stringify(pickedVariant.plan));
        const goal = wizardGoalEl.value.trim() || contract.goal || plan.task || "";
        const preset = wizardPresetEl.value || contract.preset || "team";

        contract.goal = goal;
        contract.domain = domain;
        contract.preset = preset;
        plan.task = goal;

        wizardDraft = { contract, plan };
        renderWizardSteps(plan);
      }

      function renderCaseExplorer() {
        const query = (caseSearchEl.value || "").trim().toLowerCase();
        const domain = caseDomainFilterEl.value || "all";
        const decision = caseDecisionFilterEl.value || "all";
        const filtered = allCases.filter((item) => {
          if (domain !== "all" && item.domain !== domain) return false;
          if (decision !== "all" && item.expected_decision !== decision) return false;
          if (!query) return true;
          const haystack = [item.id, item.domain, item.instruction, item.expected_rationale]
            .map((value) => String(value || "").toLowerCase())
            .join(" ");
          return haystack.includes(query);
        });

        caseSummaryEl.textContent = `${filtered.length} / ${allCases.length} cases`;
        caseListEl.innerHTML = "";
        if (!filtered.length) {
          caseListEl.innerHTML = '<div class="case-item">No matching cases.</div>';
          caseDetailEl.textContent = "";
          return;
        }

        if (!selectedCaseId || !filtered.some((item) => item.id === selectedCaseId)) {
          selectedCaseId = filtered[0].id;
        }

        filtered.forEach((item) => {
          const row = document.createElement("div");
          row.className = `case-item ${item.id === selectedCaseId ? "active" : ""}`;
          row.innerHTML = `<strong>${item.id}</strong><div class="muted">${item.domain} • ${item.expected_decision}</div><div>${item.instruction}</div>`;
          row.addEventListener("click", () => {
            selectedCaseId = item.id;
            renderCaseExplorer();
          });
          caseListEl.appendChild(row);
        });

        const selected = filtered.find((item) => item.id === selectedCaseId) || filtered[0];
        caseDetailEl.textContent = [
          `Case: ${selected.id}`,
          `Domain: ${selected.domain}`,
          `Expected decision: ${selected.expected_decision}`,
          "",
          "Instruction",
          selected.instruction || "",
          "",
          "Expected rationale",
          selected.expected_rationale || "",
          "",
          "Contract",
          JSON.stringify(selected.contract || {}, null, 2),
          "",
          "Plan",
          JSON.stringify(selected.plan || {}, null, 2),
          "",
          "Expected step vectors",
          JSON.stringify(selected.expected_step_vectors || [], null, 2)
        ].join("\n");
      }

      async function loadCatalog() {
        const [templates, tools, cases] = await Promise.all([
          fetch("/templates").then((r) => r.json()),
          fetch("/tools").then((r) => r.json()),
          fetch("/cases").then((r) => r.json()).catch(() => ({ count: 0, datasets: [], domains: [], cases: [] }))
        ]);

        wizardTemplates = templates.templates || [];
        const options = [];
        (templates.templates || []).forEach((domain) => {
          Object.entries(domain.variants || {}).forEach(([variant, body]) => {
            if (body.content?.contract && body.content?.plan) {
              options.push({ key: `${domain.domain}:${variant}`, contract: body.content.contract, plan: body.content.plan });
            }
          });
        });
        templateSelectEl.innerHTML = options.map((opt) => `<option value="${opt.key}">${opt.key}</option>`).join("");
        templateSelectEl._options = options;

        wizardDomainEl.innerHTML = wizardTemplates.map((item) => `<option value="${item.domain}">${item.domain}</option>`).join("");
        if (!wizardDomainEl.value && wizardTemplates.length) wizardDomainEl.value = wizardTemplates[0].domain;
        renderWizardVariantOptions();
        generateWizardDraft();

        knownTools = (tools.tools || []).map((item) => item.tool).filter(Boolean).sort();
        allCases = (cases.cases || []).slice().sort((a, b) => {
          const domainCmp = String(a.domain || "").localeCompare(String(b.domain || ""));
          if (domainCmp !== 0) return domainCmp;
          return String(a.id || "").localeCompare(String(b.id || ""));
        });
        caseDomainFilterEl.innerHTML = ['<option value="all">All domains</option>', ...(cases.domains || []).map((d) => `<option value="${d}">${d}</option>`)].join("");
        caseDecisionFilterEl.innerHTML = ['<option value="all">All decisions</option>', '<option value="ALLOW">ALLOW</option>', '<option value="ASK">ASK</option>', '<option value="DENY">DENY</option>'].join("");
        renderCaseExplorer();

        catalogEl.textContent = JSON.stringify({
          templates: (templates.templates || []).length,
          tools: (tools.tools || []).length,
          cases_count: cases.count || 0,
          case_domains: cases.domains || []
        }, null, 2);
        renderWhatIfEditors(JSON.parse(planEl.value));
      }

      async function loadPlugins() {
        const [marketplace, installed] = await Promise.all([
          fetch("/plugin_marketplace").then((r) => r.json()),
          fetch("/plugins").then((r) => r.json())
        ]);
        const rows = marketplace.plugins || [];
        pluginMarketplaceTableEl.innerHTML = rows.map((row) => {
          const signature = row.signature_status || "unknown";
          const status = row.installed ? "installed" : (row.status || "listed");
          return `<tr>
            <td><code>${row.plugin_bundle || "n/a"}</code></td>
            <td>${row.domain_focus || row.title || row.slug || "n/a"}</td>
            <td>${row.version || "n/a"}</td>
            <td>${signature}</td>
            <td>${status}</td>
          </tr>`;
        }).join("") || '<tr><td colspan="5" class="muted">No marketplace plugins listed.</td></tr>';
        pluginMarketplaceEl.textContent = JSON.stringify(marketplace, null, 2);
        pluginManagerEl.textContent = JSON.stringify(installed, null, 2);
      }

      function parsePolicyEditorJson(text, fallback) {
        try {
          const parsed = JSON.parse(text || "");
          return parsed == null ? fallback : parsed;
        } catch (_err) {
          return fallback;
        }
      }

      async function loadPolicyWorkbenchState() {
        const backend = policyBackendSelectEl.value || "python";
        const token = policyEditorTokenEl.value.trim();
        const headers = token ? { "X-ScopeBench-Policy-Token": token } : {};
        const payload = await fetch(`/policy/workbench?policy_backend=${encodeURIComponent(backend)}`, { headers }).then((r) => r.json());
        policyWorkbenchStateEl.textContent = JSON.stringify(payload, null, 2);
      }

      async function testPolicyWorkbenchEdits() {
        const body = {
          policy_backend: policyBackendSelectEl.value || "python",
          contract: JSON.parse(contractEl.value),
          plan: JSON.parse(planEl.value),
          threshold_overrides: parsePolicyEditorJson(policyThresholdOverridesEl.value, {}),
          proposed_rules: parsePolicyEditorJson(policyRulesProposalEl.value, [])
        };
        const response = await fetch("/policy/workbench/test", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify(body)
        }).then((r) => r.json());
        policyWorkbenchOutputEl.textContent = JSON.stringify(response, null, 2);
      }

      async function applyPolicyWorkbenchEdits() {
        const token = policyEditorTokenEl.value.trim();
        const body = {
          policy_backend: policyBackendSelectEl.value || "python",
          summary: policySummaryEl.value.trim() || null,
          contract: JSON.parse(contractEl.value),
          plan: JSON.parse(planEl.value),
          threshold_overrides: parsePolicyEditorJson(policyThresholdOverridesEl.value, {}),
          proposed_rules: parsePolicyEditorJson(policyRulesProposalEl.value, [])
        };
        const response = await fetch("/policy/workbench/apply", {
          method: "POST",
          headers: {
            "content-type": "application/json",
            ...(token ? { "X-ScopeBench-Policy-Token": token } : {})
          },
          body: JSON.stringify(body)
        }).then((r) => r.json());
        policyWorkbenchOutputEl.textContent = JSON.stringify(response, null, 2);
      }

      async function installPluginBundle() {
        const payload = { source_path: pluginSourceEl.value, plugin_dir: pluginTargetDirEl.value };
        const response = await fetch("/plugins/install", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify(payload)
        }).then((r) => r.json());
        pluginManagerEl.textContent = JSON.stringify(response, null, 2);
        await loadPlugins();
      }

      async function generatePluginWizardBundle() {
        const tools = pluginWizardToolsEl.value.split(",").map((item) => item.trim()).filter(Boolean);
        const effects = JSON.parse(pluginWizardEffectsEl.value || "[]");
        const toolDefinitions = JSON.parse(pluginWizardToolDefinitionsEl.value || "[]");
        const policyTemplates = pluginWizardPolicyEl.value.split("\n").map((line) => line.trim()).filter(Boolean);
        const payload = {
          domain: pluginWizardDomainEl.value.trim(),
          publisher: pluginWizardPublisherEl.value.trim(),
          name: pluginWizardNameEl.value.trim(),
          version: pluginWizardVersionEl.value.trim(),
          key_id: pluginWizardKeyIdEl.value.trim() || "community-main",
          secret: pluginWizardSecretEl.value,
          tools,
          tool_definitions: toolDefinitions,
          effects_mappings: effects,
          policy_rule_templates: policyTemplates,
        };
        const response = await fetch("/plugins/wizard/generate", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify(payload)
        }).then((r) => r.json());
        pluginWizardOutputEl.textContent = JSON.stringify(response, null, 2);

        const lintResponse = await fetch("/plugins/lint", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify(response.bundle || {})
        }).then((r) => r.json());
        pluginWizardLintOutputEl.textContent = JSON.stringify(lintResponse, null, 2);
      }

      async function uninstallPluginBundle() {
        const response = await fetch("/plugins/uninstall", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({ source_path: pluginSourceEl.value })
        }).then((r) => r.json());
        pluginManagerEl.textContent = JSON.stringify(response, null, 2);
        await loadPlugins();
      }

      async function runEvaluation() {
        const contract = JSON.parse(contractEl.value);
        const plan = JSON.parse(planEl.value);
        renderDag(plan);
        const res = await fetch("/evaluate", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ contract, plan, include_summary: true, include_steps: true, include_telemetry: true, calibration_domain: contract.domain || null }) });
        const payload = await res.json();
        decisionEl.innerHTML = `${decisionBadge(payload.decision)} effective=${payload.effective_decision || "n/a"}`;
        resultEl.textContent = JSON.stringify({ trace_id: payload.trace_id, span_id: payload.span_id, summary: payload.summary, next_steps: payload.next_steps, telemetry: payload.telemetry }, null, 2);
        latestEvaluation = { aggregate: payload.aggregate || {}, steps: payload.steps || [], plan };
        renderAggregate(payload.aggregate || {}); renderStepRationales(payload.steps || []); renderContributions(plan, payload.steps || [], payload.aggregate || {});
        renderEffectLabComparison();
      }

      function buildStreamingEvents(plan) {
        const steps = plan.steps || [];
        if (!steps.length) return [];
        const candidateIndex = Math.max(0, steps.length - 1);
        const candidate = steps[candidateIndex];
        const intensified = {
          ...candidate,
          description: `${candidate.description || "Step"} with broader production impact and uncertain dependencies`,
          tool_category: candidate.tool_category || "prod"
        };
        const reviewStepId = `review-${candidate.id || "step"}`;
        const reviewDepends = candidate.id ? [candidate.id] : [];
        return [
          {
            event_id: "stream-update-main-step",
            operation: "update_step",
            step_id: String(candidate.id || "1"),
            step: intensified,
            context: { label: "Intensify current step scope" }
          },
          {
            event_id: "stream-add-safety-review",
            operation: "add_step",
            step_id: reviewStepId,
            step: {
              id: reviewStepId,
              description: "Add expanded rollback + post-deploy validation rationale",
              tool: "pytest",
              depends_on: reviewDepends
            },
            context: { label: "Add new validation step" }
          }
        ];
      }

      function summarizeStreaming(payload) {
        const snapshots = [payload.initial, ...(payload.updates || [])];
        const lines = [];
        const priorByAxis = {};
        snapshots.forEach((snapshot) => {
          lines.push(`${snapshot.event_index}. ${snapshot.event_id} (${snapshot.operation}) => ${snapshot.decision}`);
          Object.entries(snapshot.aggregate || {})
            .sort((a, b) => b[1] - a[1])
            .slice(0, 3)
            .forEach(([axis, value]) => {
              const previous = priorByAxis[axis];
              const change = previous == null ? "" : ` (Δ ${(Number(value) - Number(previous)).toFixed(3)})`;
              lines.push(`   • ${axis}: ${Number(value).toFixed(3)}${change}`);
              priorByAxis[axis] = Number(value);
            });

          (snapshot.triggers || []).forEach((trigger) => {
            if (trigger.kind === "threshold_crossed") {
              lines.push(
                `   ⚠ threshold crossed on ${trigger.axis}: ${Number(trigger.previous || 0).toFixed(3)} -> ${Number(trigger.current || 0).toFixed(3)} (limit ${Number(trigger.threshold || 0).toFixed(3)})`
              );
            } else {
              lines.push(`   ↻ ${trigger.details || trigger.kind}`);
            }
          });

          (snapshot.judge_output_deltas || []).forEach((stepDelta) => {
            lines.push(`   Δ judge output for ${stepDelta.step_id}: ${stepDelta.changed_axes.join(", ") || "none"}`);
            (stepDelta.axis_deltas || []).forEach((axisDelta) => {
              const prevR = axisDelta.previous_rationale || "";
              const currR = axisDelta.current_rationale || "";
              if (prevR !== currR) {
                lines.push(`      rationale[${axisDelta.axis}]: "${prevR}" -> "${currR}"`);
              }
            });
          });
        });
        return lines.join("\n");
      }

      async function runStreamingEvaluation() {
        const contract = JSON.parse(contractEl.value);
        const plan = JSON.parse(planEl.value);
        const events = buildStreamingEvents(plan);
        const payload = await fetch("/evaluate_stream", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({
            contract,
            plan,
            events,
            include_steps: false,
            judge: "llm"
          })
        }).then((r) => r.json());

        streamingEl.textContent = summarizeStreaming(payload);
        renderAggregate(payload.aggregate || {});
        renderStepRationales(payload.steps || []);
        renderContributions(plan, payload.steps || [], payload.aggregate || {});
      }

      async function replayTelemetry() { const replay = await fetch("/telemetry/replay?limit=25").then((r) => r.json()); telemetryEl.textContent = JSON.stringify(replay, null, 2); }
      async function replayTelemetry() {
        const replay = await fetch("/telemetry/replay?limit=25").then((r) => r.json());
        telemetryEl.textContent = JSON.stringify(replay, null, 2);
      }

      async function runSessionEvaluation() {
        const body = sessionPayloadFromState();
        sessionPayloadEl.textContent = JSON.stringify(body, null, 2);
        const res = await fetch("/evaluate_session", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify(body) });
        const payload = await res.json();
        sessionDecisionEl.innerHTML = `${decisionBadge(payload.decision)} multi-agent governance result`;
        sessionResultEl.textContent = JSON.stringify({ decision: payload.decision, trace_id: payload.trace_id, negotiation: payload.negotiation }, null, 2);
        renderSessionDashboard(payload);
      }

      function clamp01(value) {
        return Math.max(0, Math.min(1, Number(value || 0)));
      }

      function axisSampleScore(entry, axis) {
        const baseline = Number(latestEvaluation?.aggregate?.[axis] || entry.calibration?.axis_distributions?.[axis]?.quantiles?.p50 || 0);
        const scale = 1 + Number(calibrationSelection.axisScaleDelta[axis] || 0);
        return clamp01(baseline * scale);
      }

      function formatPct(value) {
        return `${(100 * Number(value || 0)).toFixed(1)}%`;
      }

      async function loadCalibrationDashboard() {
        const dashboard = await fetch('/calibration/dashboard').then((r) => r.json());
        calibrationDashboardState = dashboard;
        calibrationRawEl.textContent = JSON.stringify(dashboard, null, 2);
        calibrationDomainEl.innerHTML = (dashboard.domains || []).map((entry) => `<option value="${entry.domain}">${entry.domain}</option>`).join('');
        if (!calibrationSelection.domain && dashboard.domains?.length) calibrationSelection.domain = dashboard.domains[0].domain;
        if (calibrationSelection.domain) calibrationDomainEl.value = calibrationSelection.domain;
        renderCalibrationViews();
      }

      async function applyCalibrationAdjustments() {
        if (!calibrationSelection.domain) return;
        calibrationAdjustStatusEl.textContent = 'Applying adjustments…';
        const payload = {
          domain: calibrationSelection.domain,
          axis_scale_delta: calibrationSelection.axisScaleDelta,
          axis_threshold_factor_delta: calibrationSelection.axisThresholdFactorDelta,
          abstain_uncertainty_threshold_delta: Number(calibrationSelection.abstainDelta || 0),
        };
        const res = await fetch('/calibration/adjust', {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify(payload),
        });
        const adjusted = await res.json();
        if (!res.ok) {
          calibrationAdjustStatusEl.textContent = `Adjustment failed: ${adjusted.detail || res.statusText}`;
          return;
        }
        calibrationDashboardState = adjusted;
        calibrationRawEl.textContent = JSON.stringify(adjusted, null, 2);
        calibrationAdjustStatusEl.textContent = `Applied adjustments for ${calibrationSelection.domain}.`;
        renderCalibrationViews();
      }

      function renderCalibrationControls(entry) {
        calibrationControlsEl.innerHTML = '';
        const calibration = entry?.calibration || {};
        const scales = calibration.axis_scale || {};
        const factors = calibration.axis_threshold_factor || {};

        Object.keys(scales).forEach((axis) => {
          const wrap = document.createElement('div');
          wrap.className = 'card';
          const scaleVal = Number(calibrationSelection.axisScaleDelta[axis] || 0);
          const factorVal = Number(calibrationSelection.axisThresholdFactorDelta[axis] || 0);
          wrap.innerHTML = `<h4>${axis}</h4>
            <label>Axis scale Δ <input type="range" min="-0.35" max="0.35" step="0.01" value="${scaleVal}" data-kind="scale" data-axis="${axis}" /><span class="muted">${scaleVal.toFixed(2)}</span></label>
            <label>Threshold factor Δ <input type="range" min="-0.35" max="0.35" step="0.01" value="${factorVal}" data-kind="threshold" data-axis="${axis}" /><span class="muted">${factorVal.toFixed(2)}</span></label>
            <p class="muted">Current scale=${Number(scales[axis] || 1).toFixed(2)}, threshold factor=${Number(factors[axis] || 1).toFixed(2)}</p>`;
          calibrationControlsEl.appendChild(wrap);
        });

        const abstainWrap = document.createElement('div');
        abstainWrap.className = 'card';
        abstainWrap.innerHTML = `<h4>Uncertainty abstain threshold</h4><label>Δ <input type="range" min="-0.2" max="0.2" step="0.01" value="${Number(calibrationSelection.abstainDelta || 0)}" id="calibration-abstain" /><span class="muted">${Number(calibrationSelection.abstainDelta || 0).toFixed(2)}</span></label>`;
        calibrationControlsEl.appendChild(abstainWrap);

        calibrationControlsEl.querySelectorAll('input[data-kind]').forEach((node) => {
          node.addEventListener('input', (ev) => {
            const axis = ev.target.dataset.axis;
            const val = Number(ev.target.value || 0);
            if (ev.target.dataset.kind === 'scale') calibrationSelection.axisScaleDelta[axis] = val;
            else calibrationSelection.axisThresholdFactorDelta[axis] = val;
            renderCalibrationViews();
          });
        });

        const abstainNode = el('calibration-abstain');
        if (abstainNode) {
          abstainNode.addEventListener('input', (ev) => {
            calibrationSelection.abstainDelta = Number(ev.target.value || 0);
            renderCalibrationViews();
          });
        }
      }

      function renderCalibrationViews() {
        if (!calibrationDashboardState?.domains?.length) return;
        const domain = calibrationSelection.domain || calibrationDashboardState.domains[0].domain;
        const entry = calibrationDashboardState.domains.find((item) => item.domain === domain) || calibrationDashboardState.domains[0];
        calibrationSelection.domain = entry.domain;

        const dist = entry.calibration?.axis_distributions || {};
        const rates = entry.calibration?.rates || {};
        const telemetryDelta = entry.calibration?.telemetry_delta || {};
        const thresholdBlock = entry.calibration?.preset_thresholds || {};

        const distRows = Object.entries(dist).map(([axis, item]) => {
          const bars = (item.histogram || []).map((count) => Number(count || 0));
          const maxBin = Math.max(1, ...bars);
          const binsHtml = bars.map((count) => `<span class="bar-fill" style="width:${(100 * count) / maxBin}%"></span>`);
          return `<div class="rate-card"><div class="inline-label"><strong>${axis}</strong><span class="muted">n=${item.samples || 0} • p50=${Number(item.quantiles?.p50 || 0).toFixed(2)} • p90=${Number(item.quantiles?.p90 || 0).toFixed(2)}</span></div><div class="bar-chart">${binsHtml.map((fill, idx) => `<div class="bar-row"><span class="muted">${(idx / 10).toFixed(1)}-${((idx + 1) / 10).toFixed(1)}</span><span class="bar-track">${fill}</span><span>${bars[idx]}</span></div>`).join('')}</div></div>`;
        });
        calibrationDistributionsEl.innerHTML = distRows.join('') || '<p class="muted">No data</p>';

        const rateRows = Object.entries(rates).map(([axis, item]) => {
          const tele = telemetryDelta[axis] || {};
          return `<div class="rate-card"><div class="inline-label"><strong>${axis}</strong><span class="muted">scaleΔ=${Number(tele.axis_scale_delta || 0).toFixed(3)}, thresholdΔ=${Number(tele.threshold_factor_delta || 0).toFixed(3)}</span></div><div class="bar-row"><span>false alarm</span><span class="bar-track"><span class="bar-fill" style="width:${100 * Number(item.false_alarm_rate || 0)}%"></span></span><span>${formatPct(item.false_alarm_rate)}</span></div><div class="bar-row"><span>override</span><span class="bar-track"><span class="bar-fill" style="width:${100 * Number(item.override_rate || 0)}%"></span></span><span>${formatPct(item.override_rate)}</span></div></div>`;
        });
        calibrationRatesEl.innerHTML = `<div class="rate-grid">${rateRows.join('')}</div>` || '<p class="muted">No data</p>';

        const preset = calibrationPlanPresetEl.value || 'team';
        const base = thresholdBlock.base?.[preset] || {};
        const calibrated = thresholdBlock.calibrated?.[preset] || {};
        const axes = Object.keys(base).length ? Object.keys(base) : Object.keys(dist);

        const thresholdRows = axes.map((axis) => {
          const adjustedFactor = 1 + Number(calibrationSelection.axisThresholdFactorDelta[axis] || 0);
          const adjustedThreshold = clamp01(Number(calibrated[axis] || base[axis] || 0) * adjustedFactor);
          return `<tr><td>${axis}</td><td>${Number(base[axis] || 0).toFixed(3)}</td><td>${Number(calibrated[axis] || 0).toFixed(3)}</td><td>${adjustedThreshold.toFixed(3)}</td></tr>`;
        });
        calibrationThresholdsEl.innerHTML = `<table class="threshold-table"><thead><tr><th>Axis</th><th>Base</th><th>Calibrated</th><th>Adjusted</th></tr></thead><tbody>${thresholdRows.join('')}</tbody></table>`;

        const impactRows = axes.map((axis) => {
          const adjustedFactor = 1 + Number(calibrationSelection.axisThresholdFactorDelta[axis] || 0);
          const threshold = clamp01(Number(calibrated[axis] || base[axis] || 0) * adjustedFactor);
          const score = axisSampleScore(entry, axis);
          const pressure = threshold > 0 ? score / threshold : 0;
          const status = pressure >= 1 ? '⚠ near/over threshold' : '✅ below threshold';
          return `<tr><td>${axis}</td><td>${score.toFixed(3)}</td><td>${threshold.toFixed(3)}</td><td>${pressure.toFixed(2)}x</td><td>${status}</td></tr>`;
        });
        calibrationPlanImpactEl.innerHTML = `<table class="threshold-table"><thead><tr><th>Axis</th><th>Sample score</th><th>Adjusted threshold</th><th>Pressure</th><th>Status</th></tr></thead><tbody>${impactRows.join('')}</tbody></table><p class="muted">Sample score is driven by latest evaluation aggregate when available, otherwise p50 telemetry.</p>`;

        renderCalibrationControls(entry);
      }

      function renderCasesAnalyticsDashboard(dashboard) {
        const byDomain = (dashboard.decision_distribution_by_domain || []).map((entry) => {
          const counts = entry.decision_counts || {};
          const rates = entry.decision_rates || {};
          return {
            domain: entry.domain,
            total: entry.total_cases,
            ALLOW: `${counts.ALLOW || 0} (${formatPct(rates.ALLOW || 0)})`,
            ASK: `${counts.ASK || 0} (${formatPct(rates.ASK || 0)})`,
            DENY: `${counts.DENY || 0} (${formatPct(rates.DENY || 0)})`,
          };
        });

        const triggerAxes = (dashboard.trigger_axes || []).map((entry) => ({
          axis: entry.axis,
          ASK: entry.ask_count || 0,
          DENY: entry.deny_count || 0,
        }));

        const effectVsThreshold = (dashboard.effect_magnitude_vs_threshold || []).map((entry) => ({
          axis: entry.axis,
          avg_effect: Number(entry.average_effect || 0).toFixed(3),
          avg_threshold: Number(entry.average_threshold || 0).toFixed(3),
          avg_margin: Number(entry.average_margin || 0).toFixed(3),
          over_threshold_cases: entry.over_threshold_cases || 0,
          over_threshold_rate: formatPct(entry.over_threshold_rate || 0),
        }));

        const topAxes = (dashboard.top_trigger_axes_by_decision || []).map((entry) => ({
          decision: entry.decision,
          total_cases: entry.total_cases || 0,
          top_axes: (entry.top_axes || []).map((axisRow) => `${axisRow.axis}:${axisRow.count} (${formatPct(axisRow.rate_within_decision || 0)})`).join(', '),
        }));

        const effectProfiles = (dashboard.effect_magnitude_profiles || []).map((entry) => {
          const rates = entry.decision_rates || {};
          return {
            effect_type: entry.effect_type,
            magnitude: entry.magnitude,
            count: entry.count || 0,
            ALLOW: formatPct(rates.ALLOW || 0),
            ASK: formatPct(rates.ASK || 0),
            DENY: formatPct(rates.DENY || 0),
          };
        });

        casesAnalyticsDashboardEl.textContent = JSON.stringify({
          source: dashboard.source,
          count: dashboard.count,
          decision_distribution_by_domain: byDomain,
          trigger_axes: triggerAxes,
          top_trigger_axes_by_decision: topAxes,
          effect_magnitude_vs_threshold: effectVsThreshold,
          effect_magnitude_profiles: effectProfiles,
        }, null, 2);
      }

      async function loadCasesAnalyticsDashboard() {
        const dashboard = await fetch('/cases/analytics').then((r) => r.json());
        renderCasesAnalyticsDashboard(dashboard);
      }

      async function validateCaseDraft() {
        setDatasetWizardStep("validate", "running", "running");
        const payload = { case: JSON.parse(caseDraftEl.value) };
        const res = await fetch("/dataset/validate", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify(payload)
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.detail || JSON.stringify(data));
        setDatasetWizardStep("validate", "done", `valid (${data.case_id})`);
        datasetOutputEl.textContent = `Validation OK for case: ${data.case_id}`;
      }

      async function suggestCaseVectors() {
        setDatasetWizardStep("suggest", "running", "running");
        const contract = JSON.parse(contractEl.value);
        const plan = JSON.parse(planEl.value);
        const draft = JSON.parse(caseDraftEl.value);
        const payload = {
          id: draft.id || "community_case_001",
          domain: draft.domain || "engineering",
          instruction: draft.instruction || contract.goal || "Community contribution",
          contract,
          plan,
          expected_decision: draft.expected_decision || "ALLOW",
          expected_rationale: draft.expected_rationale || "TBD",
          notes: draft.notes || null
        };
        const res = await fetch("/dataset/suggest", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify(payload)
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.detail || JSON.stringify(data));
        caseDraftEl.value = JSON.stringify(data.case, null, 2);
        syncDatasetFieldsFromDraft(data.case);
        setDatasetWizardStep("suggest", "done", "vectors filled");
        datasetOutputEl.textContent = "Suggested vectors loaded into draft.";
      }

      function buildCaseDraftFromInputs() {
        const contract = JSON.parse(contractEl.value);
        const plan = JSON.parse(planEl.value);
        const existing = (() => {
          try { return JSON.parse(caseDraftEl.value); } catch (_err) { return {}; }
        })();
        const next = {
          case_schema_version: existing.case_schema_version || "1.0",
          id: datasetCaseIdEl.value.trim() || existing.id || "community_case_001",
          domain: datasetDomainEl.value.trim() || existing.domain || contract.domain || "engineering",
          instruction: datasetInstructionEl.value.trim() || existing.instruction || contract.goal || plan.task || "Community contribution",
          contract,
          plan,
          expected_decision: datasetExpectedDecisionEl.value || existing.expected_decision || "ALLOW",
          expected_rationale: datasetExpectedRationaleEl.value.trim() || existing.expected_rationale || "TBD",
          expected_step_vectors: Array.isArray(existing.expected_step_vectors) ? existing.expected_step_vectors : [],
          notes: existing.notes || null,
        };
        caseDraftEl.value = JSON.stringify(next, null, 2);
        setDatasetWizardStep("build", "done", "draft ready");
        return next;
      }

      function syncDatasetFieldsFromDraft(draft) {
        if (!draft || typeof draft !== "object") return;
        datasetCaseIdEl.value = draft.id || datasetCaseIdEl.value;
        datasetDomainEl.value = draft.domain || datasetDomainEl.value;
        datasetInstructionEl.value = draft.instruction || datasetInstructionEl.value;
        datasetExpectedDecisionEl.value = draft.expected_decision || datasetExpectedDecisionEl.value;
        datasetExpectedRationaleEl.value = draft.expected_rationale || datasetExpectedRationaleEl.value;
      }

      function generateDatasetJsonlLine() {
        const draft = buildCaseDraftFromInputs();
        const jsonlLine = JSON.stringify(draft);
        datasetContributionFileEl.value = `${jsonlLine}\n`;
        setDatasetWizardStep("generate", "done", "jsonl ready");
        datasetOutputEl.textContent = jsonlLine;
      }

      async function runDatasetContributionWizard() {
        resetDatasetWizardSteps();
        datasetContributionFileEl.value = "";
        try {
          setDatasetWizardStep("build", "running", "running");
          buildCaseDraftFromInputs();
          await suggestCaseVectors();
          await validateCaseDraft();
          generateDatasetJsonlLine();
          datasetOutputEl.textContent = "Wizard complete: draft built, vectors suggested, validation passed, contribution file generated.";
        } catch (err) {
          if (datasetStepEls.build.textContent === "running") setDatasetWizardStep("build", "error", "error");
          if (datasetStepEls.suggest.textContent === "running") setDatasetWizardStep("suggest", "error", "error");
          if (datasetStepEls.validate.textContent === "running") setDatasetWizardStep("validate", "error", "error");
          if (datasetStepEls.generate.textContent === "running") setDatasetWizardStep("generate", "error", "error");
          throw err;
        }
      }

      function generateDatasetPrText() {
        const draft = buildCaseDraftFromInputs();
        const title = `dataset: add ${draft.id}`;
        const body = [
          `## Summary`,
          `- Add benchmark case \`${draft.id}\` in domain \`${draft.domain}\`.`,
          `- Instruction: ${draft.instruction}`,
          `- Expected decision: ${draft.expected_decision}`,
          ``,
          `## Case JSONL`,
          "```json",
          JSON.stringify(draft),
          "```",
          ``,
          `## Validation`,
          `- [ ] Run \`scopebench dataset-validate <path/to/cases.jsonl>\``,
          `- [ ] Run \`scopebench dataset-pr --cases <path/to/cases.jsonl>\``,
        ].join("\n");
        datasetOutputEl.textContent = `Title:
${title}

Body:
${body}`;
      }

      el("load-template").addEventListener("click", () => {
        const picked = (templateSelectEl._options || []).find((opt) => opt.key === templateSelectEl.value);
        if (!picked) return;
        contractEl.value = JSON.stringify(picked.contract, null, 2);
        planEl.value = JSON.stringify(picked.plan, null, 2);
        renderDag(picked.plan);
        renderWhatIfEditors(picked.plan);
        scheduleAutoEvaluate();
      });
      el("run").addEventListener("click", () => runEvaluation().catch((err) => {
        resultEl.textContent = `Error: ${err.message}`;
      }));
      el("run-session").addEventListener("click", () => runSessionEvaluation().catch((err) => {
        sessionResultEl.textContent = `Error: ${err.message}`;
      }));
      el("replay").addEventListener("click", () => replayTelemetry().catch((err) => {
        telemetryEl.textContent = `Error: ${err.message}`;
      }));
      el("calibration").addEventListener("click", () => loadCalibrationDashboard().catch((err) => {
        calibrationRawEl.textContent = `Error: ${err.message}`;
      }));
      el("cases-analytics").addEventListener("click", () => loadCasesAnalyticsDashboard().catch((err) => {
        casesAnalyticsDashboardEl.textContent = `Error: ${err.message}`;
      }));
      calibrationDomainEl.addEventListener("change", (ev) => {
        calibrationSelection.domain = ev.target.value;
        calibrationSelection.axisScaleDelta = {};
        calibrationSelection.axisThresholdFactorDelta = {};
        calibrationSelection.abstainDelta = 0;
        calibrationAdjustStatusEl.textContent = '';
        renderCalibrationViews();
      });
      calibrationPlanPresetEl.addEventListener("change", () => renderCalibrationViews());
      calibrationApplyAdjustmentsEl.addEventListener("click", () => {
        applyCalibrationAdjustments().catch((err) => {
          calibrationAdjustStatusEl.textContent = `Adjustment failed: ${err.message}`;
        });
      });
      el("dataset-validate").addEventListener("click", () => validateCaseDraft().catch((err) => {
        datasetOutputEl.textContent = `Validation error: ${err.message}`;
      }));
      el("dataset-suggest").addEventListener("click", () => suggestCaseVectors().catch((err) => {
        datasetOutputEl.textContent = `Suggestion error: ${err.message}`;
      }));
      el("dataset-build").addEventListener("click", () => {
        try { buildCaseDraftFromInputs(); datasetOutputEl.textContent = "Draft rebuilt from current contract + plan."; }
        catch (err) { setDatasetWizardStep("build", "error", "error"); datasetOutputEl.textContent = `Draft build error: ${err.message}`; }
      });
      el("dataset-validate-panel").addEventListener("click", () => {
        try { buildCaseDraftFromInputs(); }
        catch (err) { datasetOutputEl.textContent = `Draft build error: ${err.message}`; return; }
        validateCaseDraft().catch((err) => { setDatasetWizardStep("validate", "error", "error"); datasetOutputEl.textContent = `Validation error: ${err.message}`; });
      });
      el("dataset-suggest-panel").addEventListener("click", () => {
        try { buildCaseDraftFromInputs(); }
        catch (err) { datasetOutputEl.textContent = `Draft build error: ${err.message}`; return; }
        suggestCaseVectors().catch((err) => { setDatasetWizardStep("suggest", "error", "error"); datasetOutputEl.textContent = `Suggestion error: ${err.message}`; });
      });
      el("dataset-generate-file").addEventListener("click", () => {
        try { generateDatasetJsonlLine(); }
        catch (err) { setDatasetWizardStep("generate", "error", "error"); datasetOutputEl.textContent = `Generate file error: ${err.message}`; }
      });
      el("dataset-run-wizard").addEventListener("click", () => runDatasetContributionWizard().catch((err) => {
        datasetOutputEl.textContent = `Wizard error: ${err.message}`;
      }));
      el("dataset-generate-pr").addEventListener("click", () => {
        try { generateDatasetPrText(); }
        catch (err) { datasetOutputEl.textContent = `Generate PR text error: ${err.message}`; }
      });
      suggestEffectsEl.addEventListener("click", () => suggestEffectsForPlan().catch((err) => {
        resultEl.textContent = `Suggest effects error: ${err.message}`;
      }));
      el("stream").addEventListener("click", () => runStreamingEvaluation().catch((err) => {
        streamingEl.textContent = `Error: ${err.message}`;
      }));
      el("refresh-plugins").addEventListener("click", () => loadPlugins().catch((err) => {
        pluginManagerEl.textContent = `Plugin refresh error: ${err.message}`;
        pluginManagerEl.textContent = `Error: ${err.message}`;
        pluginManagerEl.textContent = `Plugin load error: ${err.message}`;
      }));
      el("plugin-install").addEventListener("click", () => installPluginBundle().catch((err) => {
        pluginManagerEl.textContent = `Install error: ${err.message}`;
      }));
      el("plugin-uninstall").addEventListener("click", () => uninstallPluginBundle().catch((err) => {
        pluginManagerEl.textContent = `Uninstall error: ${err.message}`;
      }));
      el("plugin-wizard-generate").addEventListener("click", () => generatePluginWizardBundle().catch((err) => {
        pluginWizardOutputEl.textContent = `Wizard error: ${err.message}`;
      }));
      el("policy-refresh").addEventListener("click", () => loadPolicyWorkbenchState().catch((err) => {
        policyWorkbenchStateEl.textContent = `State error: ${err.message}`;
      }));
      el("policy-test").addEventListener("click", () => testPolicyWorkbenchEdits().catch((err) => {
        policyWorkbenchOutputEl.textContent = `Test error: ${err.message}`;
      }));
      el("policy-apply").addEventListener("click", () => applyPolicyWorkbenchEdits().catch((err) => {
        policyWorkbenchOutputEl.textContent = `Apply error: ${err.message}`;
      }));
      el("refresh-cases").addEventListener("click", () => loadCatalog().catch((err) => {
        catalogEl.textContent = `Catalog load error: ${err.message}`;
      }));
      [caseSearchEl, caseDomainFilterEl, caseDecisionFilterEl].forEach((node) => node.addEventListener("input", renderCaseExplorer));
      el("run").addEventListener("click", () => runEvaluation().catch((err) => { resultEl.textContent = `Error: ${err.message}`; }));
      el("run-session").addEventListener("click", () => runSessionEvaluation().catch((err) => { sessionResultEl.textContent = `Error: ${err.message}`; }));
      el("replay").addEventListener("click", () => replayTelemetry().catch((err) => { telemetryEl.textContent = `Error: ${err.message}`; }));
      el("calibration").addEventListener("click", () => loadCalibrationDashboard().catch((err) => { calibrationRawEl.textContent = `Error: ${err.message}`; }));
      el("cases-analytics").addEventListener("click", () => loadCasesAnalyticsDashboard().catch((err) => { casesAnalyticsDashboardEl.textContent = `Error: ${err.message}`; }));
      el("refresh-plugins").addEventListener("click", () => loadPlugins().catch((err) => { pluginManagerEl.textContent = `Plugin load error: ${err.message}`; }));
      el("plugin-install").addEventListener("click", () => installPluginBundle().catch((err) => { pluginManagerEl.textContent = `Install error: ${err.message}`; }));
      el("plugin-uninstall").addEventListener("click", () => uninstallPluginBundle().catch((err) => { pluginManagerEl.textContent = `Uninstall error: ${err.message}`; }));
      el("add-agent").addEventListener("click", () => {
        const idx = sessionState.agents.length + 1;
        sessionState.agents.push({ agent_id: `agent-${idx}`, budgets: { cost_usd: 25, time_horizon_days: 2, max_tool_calls: 2 }, plan: { task: `agent-${idx} task`, steps: [{ id: "1", description: "Describe step", tool: knownTools[0] || "analysis" }] } });
        renderSessionBuilder();
      });
      el("sync-from-current-plan").addEventListener("click", () => {
        const parsedPlan = JSON.parse(planEl.value);
        if (!sessionState.agents.length) sessionState.agents.push({ agent_id: "agent-1", budgets: { cost_usd: 25, time_horizon_days: 2, max_tool_calls: 2 }, plan: parsedPlan });
        else sessionState.agents[0].plan = parsedPlan;
        renderSessionBuilder();
      });
      ["session-budget-cost", "session-budget-time", "session-budget-tools"].forEach((id) => el(id).addEventListener("input", () => {
        sessionPayloadEl.textContent = JSON.stringify(sessionPayloadFromState(), null, 2);
      }));

      [effectLabModeEl, effectLabExplicitEl, effectLabPriorsEl, effectLabHeuristicsEl].forEach((node) => {
        node.addEventListener("input", () => renderEffectLabComparison());
        node.addEventListener("change", () => renderEffectLabComparison());
      });

      planEl.addEventListener("input", () => {
        try { const plan = JSON.parse(planEl.value); renderDag(plan); renderWhatIfEditors(plan); scheduleAutoEvaluate(); }
        catch (_err) { /* continue editing invalid JSON */ }
      });
      caseDraftEl.addEventListener("input", () => {
        try { syncDatasetFieldsFromDraft(JSON.parse(caseDraftEl.value)); }
        catch (_err) { /* continue editing invalid JSON */ }
      });

      renderEffectLabWeightControls();
      renderDag(defaultPlan);
      renderWhatIfEditors(defaultPlan);
      renderEffectLabComparison();
      wizardDomainEl.addEventListener("change", () => {
        renderWizardVariantOptions();
        generateWizardDraft();
      });
      wizardVariantEl.addEventListener("change", () => generateWizardDraft());
      wizardGoalEl.addEventListener("input", () => generateWizardDraft());
      wizardPresetEl.addEventListener("change", () => generateWizardDraft());
      el("wizard-generate").addEventListener("click", () => generateWizardDraft());
      el("wizard-apply").addEventListener("click", () => {
        if (!wizardDraft) return;
        contractEl.value = JSON.stringify(wizardDraft.contract, null, 2);
        planEl.value = JSON.stringify(wizardDraft.plan, null, 2);
        renderDag(wizardDraft.plan);
        renderWhatIfEditors(wizardDraft.plan);
        scheduleAutoEvaluate();
      });

      loadCatalog().then(() => { runEvaluation(); loadPlugins(); }).catch((err) => {
        catalogEl.textContent = `Catalog load error: ${err.message}`;
      });
      loadPlugins().catch((err) => {
        pluginManagerEl.textContent = `Plugin load error: ${err.message}`;
      });
      loadCalibrationDashboard().catch((err) => {
        calibrationRawEl.textContent = `Calibration load error: ${err.message}`;
      });
      loadCasesAnalyticsDashboard().catch((err) => {
        casesAnalyticsDashboardEl.textContent = `Analytics load error: ${err.message}`;
      });
      runStreamingEvaluation().catch((err) => {
        streamingEl.textContent = `Streaming load error: ${err.message}`;
      });
      renderSessionBuilder();
      renderSessionBuilder();
      loadCatalog().then(() => runEvaluation()).catch((err) => { catalogEl.textContent = `Catalog load error: ${err.message}`; });
      loadCalibrationDashboard().catch((err) => { calibrationRawEl.textContent = `Calibration load error: ${err.message}`; });
      loadCasesAnalyticsDashboard().catch((err) => { casesAnalyticsDashboardEl.textContent = `Analytics load error: ${err.message}`; });
      runEvaluation().catch((err) => { resultEl.textContent = `Error: ${err.message}`; });
      runStreamingEvaluation().catch((err) => { streamingEl.textContent = `Streaming load error: ${err.message}`; });
      loadPlugins().catch((err) => { pluginManagerEl.textContent = `Plugin load error: ${err.message}`; });
      runSessionEvaluation().catch((err) => { sessionResultEl.textContent = `Error: ${err.message}`; });
    }
      loadPlugins().catch((err) => { pluginManagerEl.textContent = `Plugin load error: ${err.message}`; });
      loadPolicyWorkbenchState().catch((err) => { policyWorkbenchStateEl.textContent = `Policy state load error: ${err.message}`; });
    }
    </script>
  </body>
</html>
